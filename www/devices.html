<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="0.0.16">
    <meta name="version" content="0.0.16" data-build="2025-12-28">
    <title>Devices - Visual Mapper</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="css/styles.css?v=0.0.16">
</head>
<body>
    <nav>
        <ul>
            <!-- High priority - always visible -->
            <li class="nav-priority-high"><a href="main.html">Dashboard</a></li>
            <li class="nav-priority-high"><a href="devices.html" class="active">Devices</a></li>
            <li class="nav-priority-high"><a href="sensors.html">Sensors</a></li>

            <!-- Medium priority - hidden on mobile -->
            <li class="nav-priority-med"><a href="actions.html">Actions</a></li>
            <li class="nav-priority-med"><a href="flows.html">Flows</a></li>
            <li class="nav-priority-med"><a href="performance.html">Performance</a></li>
            <li class="nav-priority-med"><a href="diagnostic.html">Diagnostics</a></li>

            <!-- Low priority - hidden on tablet -->
            <li class="nav-priority-med"><a href="navigation-learn.html">Learn Nav</a></li>
            <li class="nav-priority-low"><a href="live-stream.html">Live Stream</a></li>
            <li class="nav-priority-low"><a href="dev.html">Dev Tools</a></li>

            <li class="version">v0.0.6</li>
            <li class="nav-logo"><img src="favicon.svg" alt="Visual Mapper"></li>
            <li id="themeToggleContainer"></li>
        </ul>
    </nav>

    <div class="container">
        <div class="card">
            <h1>Device Management</h1>
            <p>Manage Android devices connected via ADB</p>
        </div>

        <div class="card">
            <h2>Connect Device</h2>

            <div style="margin-bottom: 15px;">
                <label for="connectionType" style="display: block; margin-bottom: 5px; font-weight: bold;">Connection Type:</label>
                <select id="connectionType" style="padding: 8px; width: 300px;">
                    <option value="tcp">TCP/IP - Legacy (Port 5555)</option>
                    <option value="wireless">Wireless ADB - Android 11+ (Port 5555)</option>
                    <option value="pairing">Wireless Pairing - Android 11+ (Port varies)</option>
                    <option value="tls">TLS/Secure ADB (Custom Port)</option>
                </select>
            </div>

            <div id="tcpConfig" style="margin-bottom: 20px;">
                <label for="deviceHost">Device IP Address:</label>
                <input type="text" id="deviceHost" placeholder="192.168.1.100" style="margin: 10px 0; padding: 8px; width: 200px;">

                <label for="devicePort" style="margin-left: 20px;">Port:</label>
                <input type="number" id="devicePort" value="5555" style="margin: 10px 0; padding: 8px; width: 80px;">
            </div>

            <div id="pairingConfig" style="margin-bottom: 20px; display: none;">
                <p style="background: #e3f2fd; padding: 10px; border-left: 3px solid #2196f3; margin-bottom: 15px;">
                    <strong>Android 11+ Wireless Pairing:</strong><br>
                    1. Settings ‚Üí Developer Options ‚Üí Wireless debugging<br>
                    2. Tap "Pair device with pairing code"<br>
                    3. You'll see TWO ports - enter BOTH below along with the 6-digit code
                </p>

                <label for="pairingCode">Pairing Code (6-digit):</label>
                <input type="text" id="pairingCode" placeholder="123456" maxlength="6" style="margin: 10px 0; padding: 8px; width: 100px;">

                <label for="pairingHost" style="margin-left: 20px;">Device IP:</label>
                <input type="text" id="pairingHost" placeholder="192.168.86.2" style="margin: 10px 0; padding: 8px; width: 150px;">

                <br>

                <label for="pairingPort">Pairing Port:</label>
                <input type="number" id="pairingPort" placeholder="37899" style="margin: 10px 0; padding: 8px; width: 100px;">

                <label for="connectionPort" style="margin-left: 20px;">Connection Port:</label>
                <input type="number" id="connectionPort" placeholder="45441" style="margin: 10px 0; padding: 8px; width: 100px;">
            </div>

            <div id="wirelessConfig" style="margin-bottom: 20px; display: none;">
                <p style="background: #e3f2fd; padding: 10px; border-left: 3px solid #2196f3;">
                    <strong>Wireless ADB Setup (Android 11+):</strong><br>
                    1. Enable Developer Options on your Android device<br>
                    2. Go to Settings ‚Üí Developer Options ‚Üí Wireless debugging<br>
                    3. Tap "Wireless debugging" to enable it<br>
                    4. Note the IP address and port shown (e.g., 192.168.1.100:5555)<br>
                    5. Enter them below
                </p>
            </div>

            <div id="tlsConfig" style="margin-bottom: 20px; display: none;">
                <p style="background: #fff3cd; padding: 10px; border-left: 3px solid #ffc107;">
                    <strong>TLS/Secure ADB:</strong><br>
                    Advanced secure connection with certificate authentication.<br>
                    Requires pre-configured certificates on both client and device.
                </p>
            </div>

            <button id="connectBtn" style="padding: 8px 16px;">Connect Device</button>
            <p class="status" id="connectionStatus"></p>
        </div>

        <!-- Network Device Discovery -->
        <div class="card">
            <h2>Network Device Discovery</h2>
            <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 15px;">
                Automatically scan your local network for Android devices with ADB enabled.
                The system will detect Android version and recommend the optimal connection method.
            </p>

            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <button id="scanNetworkBtn" class="btn" style="padding: 10px 20px;">
                    üîç Scan Network
                </button>
                <span id="scanStatus" style="color: var(--text-secondary); font-size: 13px;"></span>
            </div>

            <div id="discoveredDevicesContainer" style="display: none;">
                <h3 style="margin: 20px 0 10px 0;">Discovered Devices</h3>
                <div id="discoveredDevicesList"></div>
            </div>

            <div id="noDevicesFound" style="display: none; padding: 15px; background: var(--background-color); border-radius: 6px; color: var(--text-secondary);">
                No devices found on the network. Make sure:
                <ul style="margin: 10px 0 0 20px;">
                    <li>Device is connected to the same network</li>
                    <li>ADB debugging is enabled (Developer Options)</li>
                    <li>For Android 10 and older: WiFi ADB is enabled (adb tcpip 5555)</li>
                    <li>For Android 11+: Wireless debugging is enabled</li>
                </ul>
            </div>
        </div>

        <div class="card">
            <h2>Connected Devices</h2>
            <div id="devicesList"></div>
        </div>

        <!-- Saved WiFi Devices for Quick Reconnection -->
        <div class="card">
            <h2>Saved WiFi Devices</h2>
            <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 15px;">
                Previously paired WiFi devices for quick reconnection
            </p>
            <div id="savedDevicesList"></div>
            <div id="noSavedDevices" style="display: none; color: var(--text-secondary); font-style: italic;">
                No saved devices. Connect a WiFi device and save it for quick reconnection.
            </div>
        </div>

        <!-- Device Selector - TOP LEVEL for all sections below -->
        <div class="card">
            <h2>Select Device</h2>
            <p>Choose a device to control, view apps, and capture screenshots</p>
            <div style="margin-top: 15px;">
                <select id="deviceSelect" style="width: 100%; max-width: 500px; padding: 10px; font-size: 16px;">
                    <option value="">-- Select Device --</option>
                </select>
            </div>
        </div>

        <!-- Reconfigure Device Modal -->
        <div id="reconfigureModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: var(--card-background, white); padding: 30px; border-radius: 12px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
                <h3 style="margin: 0 0 20px 0; color: var(--text-color);">Configure Device</h3>
                <p style="color: var(--text-secondary); margin-bottom: 15px;">
                    Device: <strong id="reconfigureDeviceId"></strong>
                </p>

                <!-- Tab Navigation -->
                <div style="border-bottom: 2px solid var(--border-color); margin-bottom: 20px;">
                    <button id="tab-connection" class="config-tab active" style="padding: 10px 20px; background: none; border: none; border-bottom: 2px solid var(--primary-color); color: var(--primary-color); font-weight: 600; cursor: pointer; margin-right: 10px;">
                        Connection
                    </button>
                    <button id="tab-security" class="config-tab" style="padding: 10px 20px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text-secondary); cursor: pointer;">
                        Lock Screen Security
                    </button>
                </div>

                <!-- Connection Tab Content -->
                <div id="content-connection" class="tab-content">
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">
                        Update the IP address and port for this device.
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">New IP Address:</label>
                        <input type="text" id="newDeviceHost" placeholder="192.168.1.100" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px;">Port:</label>
                        <input type="number" id="newDevicePort" value="5555" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px;">
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="reconfigureCancel" class="btn btn-secondary">Cancel</button>
                        <button id="reconfigureConfirm" class="btn btn-primary">Reconnect</button>
                    </div>
                </div>

                <!-- Security Tab Content -->
                <div id="content-security" class="tab-content" style="display: none;">
                    <div id="securityConfigContainer">
                        <!-- Security config UI will be injected here by device-security.js -->
                        <p style="text-align: center; color: var(--text-secondary);">Loading security settings...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- App Launcher Section -->
        <div class="card">
            <h2>App Launcher</h2>
            <p>Launch apps on the selected device above</p>

            <div style="margin-top: 15px;">
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                    <button id="refreshAppsBtn" class="btn btn-secondary" style="white-space: nowrap;">Load Apps</button>
                    <label style="white-space: nowrap;">
                        <input type="checkbox" id="showSystemApps"> Show System Apps
                    </label>
                    <input type="text" id="appSearch" placeholder="Type to search apps (auto-loads if needed)..." style="flex: 1; padding: 8px; max-width: 300px;">
                </div>

                <!-- Live search results preview -->
                <div id="appSearchResults" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 10px; display: none; background: var(--card-background);"></div>

                <div style="display: flex; gap: 10px; align-items: center;">
                    <select id="appSelect" style="flex: 1; padding: 8px; min-width: 300px;">
                        <option value="">Select device above and click 'Load Apps'...</option>
                    </select>
                    <button id="launchAppBtn" class="btn" style="white-space: nowrap;">Launch App</button>
                </div>

                <p class="status" id="appLauncherStatus"></p>
            </div>
        </div>

        <!-- Icon Management Section (Phase 8 Enhancement) -->
        <div class="card">
            <h2>App Icon Management</h2>
            <p>Scrape high-quality device-specific app icons (adaptive icons, themes, custom packs)</p>

            <div style="margin-top: 15px;">
                <!-- Cache Status -->
                <div id="iconCacheStatus" style="background: var(--surface); padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 5px;">Cached Icons</div>
                            <div id="iconCount" style="font-size: 24px; font-weight: bold; color: var(--text-primary);">-</div>
                        </div>
                        <div>
                            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 5px;">Cache Size</div>
                            <div id="cacheSize" style="font-size: 24px; font-weight: bold; color: var(--text-primary);">-</div>
                        </div>
                        <div>
                            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 5px;">New Apps</div>
                            <div id="newAppsCount" style="font-size: 24px; font-weight: bold; color: var(--text-primary);">-</div>
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="checkIconCacheBtn" class="btn btn-secondary" style="white-space: nowrap;">Check Cache Status</button>
                    <button id="scrapeIconsBtn" class="btn btn-primary" style="white-space: nowrap;">Scrape Device Icons</button>
                    <button id="viewCacheStatsBtn" class="btn btn-secondary" style="white-space: nowrap;">View All Stats</button>
                </div>
                <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                    üí° <strong>Smart Auto-Caching:</strong> First time you view an app, it shows SVG placeholder and fetches real icon in background. Next time = instant load from persistent cache. No ADB blocking!
                </p>

                <!-- Progress -->
                <div id="iconScrapeProgress" style="background: var(--surface); padding: 15px; border-radius: 8px; margin-top: 15px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <div class="spinner" style="width: 20px; height: 20px; border: 3px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div id="scrapeProgressText" style="color: var(--text-primary); font-weight: 500;">Scraping device icons...</div>
                    </div>
                    <div id="scrapeProgressDetail" style="font-size: 14px; color: var(--text-secondary);"></div>
                </div>

                <p class="status" id="iconMgmtStatus"></p>
            </div>
        </div>

        <div class="card">
            <h2>Screenshot Capture & Device Control</h2>
            <div style="margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button id="captureBtn">Capture Screenshot</button>
                    <button id="refreshBtn">Refresh Now</button>
                </div>
                <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                    <label>
                        <input type="checkbox" id="autoRefreshToggle"> Auto-refresh
                    </label>
                    <select id="refreshInterval">
                        <option value="1000">Every 1s</option>
                        <option value="2000">Every 2s</option>
                        <option value="3000" selected>Every 3s</option>
                        <option value="5000">Every 5s</option>
                        <option value="10000">Every 10s</option>
                    </select>
                    <label>
                        <input type="checkbox" id="smartRefreshToggle"> Smart Refresh
                    </label>
                </div>
            </div>

            <div class="control-section">
                <strong>Device Control:</strong>
                <div style="margin-bottom: 12px;">
                    <div class="button-group-toggle">
                        <input type="radio" name="interactionMode" id="modeTap" value="tap" checked>
                        <label for="modeTap">Tap</label>
                        <input type="radio" name="interactionMode" id="modeSwipe" value="swipe">
                        <label for="modeSwipe">Swipe</label>
                        <input type="radio" name="interactionMode" id="modeSensor" value="sensor">
                        <label for="modeSensor">Sensor</label>
                        <input type="radio" name="interactionMode" id="modeAction" value="action">
                        <label for="modeAction">Action</label>
                    </div>
                </div>
                <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                    <label for="textInput" style="white-space: nowrap;">Type Text:</label>
                    <input type="text" id="textInput" placeholder="Enter text to type on device" style="flex: 1; max-width: 300px;">
                    <button id="sendTextBtn">Send</button>
                </div>
                <div>
                    <strong style="font-size: 14px;">Hardware Keys:</strong>
                    <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                        <button id="homeBtn" style="padding: 6px 12px;">Home</button>
                        <button id="backBtn" style="padding: 6px 12px;">Back</button>
                        <button id="recentBtn" style="padding: 6px 12px;">Recent</button>
                        <button id="volumeUpBtn" style="padding: 6px 12px;">Vol+</button>
                        <button id="volumeDownBtn" style="padding: 6px 12px;">Vol-</button>
                    </div>
                </div>
            </div>

            <div class="overlay-section">
                <strong>Overlay Filters:</strong>
                <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 8px;">
                    <label>
                        <input type="checkbox" id="filterClickable" checked> Clickable
                    </label>
                    <label>
                        <input type="checkbox" id="filterNonClickable" checked> Non-Clickable
                    </label>
                    <label>
                        <input type="checkbox" id="filterTextLabels" checked> Text Labels
                    </label>
                    <label>
                        <input type="checkbox" id="filterMinSize"> Hide Small (&lt;50px)
                    </label>
                    <label>
                        <input type="checkbox" id="filterTextOnly"> Text Only
                    </label>
                </div>
            </div>

            <canvas id="screenshotCanvas" style="border: 1px solid #ccc; max-width: 100%; display: block; cursor: crosshair;"></canvas>
            <p class="status" id="screenshotStatus"></p>
        </div>
    </div>

    <script type="module">
        import APIClient from './js/modules/api-client.js?v=0.0.6';
        import ScreenshotCapture from './js/modules/screenshot-capture.js?v=0.0.6';
        import DeviceControl from './js/modules/device-control.js?v=0.0.6';
        import AutoRefresh from './js/modules/auto-refresh.js?v=0.0.6';
        import ActivityMonitor from './js/modules/activity-monitor.js?v=0.0.6';
        import DeviceManager from './js/modules/device-manager.js?v=0.0.6';
        import OverlayFilters from './js/modules/overlay-filters.js?v=0.0.6';
        import ElementSelector from './js/modules/element-selector.js?v=0.0.6';
        import SensorCreator from './js/modules/sensor-creator.js?v=0.0.6';
        import ActionManager from './js/modules/action-manager.js?v=0.0.6';
        import IconRenderer from './js/modules/icon-renderer.js?v=0.0.6';
        import ThemeToggle from './js/modules/theme-toggle.js?v=0.0.6';
        import MobileNav from './js/modules/mobile-nav.js?v=0.0.6';
        import DeviceSecurityUI from './js/modules/device-security.js?v=0.0.7';

        const apiClient = new APIClient();
        const canvas = document.getElementById('screenshotCanvas');
        const screenshotCapture = new ScreenshotCapture(apiClient, canvas);
        const deviceControl = new DeviceControl(apiClient, screenshotCapture);
        const autoRefresh = new AutoRefresh(screenshotCapture);
        const activityMonitor = new ActivityMonitor(apiClient);
        const deviceManager = new DeviceManager(apiClient);
        const overlayFilters = new OverlayFilters(screenshotCapture);
        const elementSelector = new ElementSelector(canvas, screenshotCapture);
        const sensorCreator = new SensorCreator(apiClient);
        const actionManager = new ActionManager(apiClient);
        const themeToggle = new ThemeToggle();
        const mobileNav = new MobileNav();
        const deviceSecurityUI = new DeviceSecurityUI();

        // Apply theme immediately
        themeToggle.apply();

        // Initialize mobile navigation
        mobileNav.init();

        // Add theme toggle button to nav
        const themeToggleContainer = document.getElementById('themeToggleContainer');
        if (themeToggleContainer) {
            const toggleButton = themeToggle.createToggleButton((newTheme) => {
                console.log('Theme changed to:', newTheme);
            });
            themeToggleContainer.appendChild(toggleButton);
        }

        // Enable interactive canvas
        deviceControl.enableInteractiveCanvas(canvas, (result) => {
            const status = document.getElementById('screenshotStatus');

            // Pause auto-refresh when user interacts with device
            if (result.type === 'tap' || result.type === 'swipe') {
                autoRefresh.pauseTemporarily(3000); // Pause for 3 seconds
            }

            if (result.error) {
                status.textContent = `‚úó ${result.error}`;
                status.className = 'status error';
            } else if (result.type === 'tap') {
                status.textContent = `‚úì Tapped at (${result.x}, ${result.y})`;
                status.className = 'status success';
            } else if (result.type === 'swipe') {
                status.textContent = `‚úì Swiped from (${result.from.x}, ${result.from.y}) to (${result.to.x}, ${result.to.y})`;
                status.className = 'status success';
            }
        });

        // Handle interaction mode changes
        document.querySelectorAll('input[name="interactionMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const mode = e.target.value;

                if (mode === 'sensor') {
                    // Enable sensor creation mode
                    deviceControl.setMode('none'); // Disable device control
                    elementSelector.enable((element, elementIndex) => {
                        // Callback when element is selected
                        const deviceId = deviceManager.getSelectedDevice();
                        if (deviceId) {
                            sensorCreator.show(deviceId, element, elementIndex);
                        } else {
                            alert('Please select a device first');
                        }
                    });
                    canvas.style.cursor = 'crosshair';
                } else if (mode === 'action') {
                    // Enable action creation mode
                    deviceControl.setMode('none'); // Disable device control
                    elementSelector.enable((element, elementIndex) => {
                        // Callback when element is selected
                        const deviceId = deviceManager.getSelectedDevice();
                        if (deviceId) {
                            showActionCreator(deviceId, element, elementIndex);
                        } else {
                            alert('Please select a device first');
                        }
                    });
                    canvas.style.cursor = 'crosshair';
                } else {
                    // Normal device control mode
                    elementSelector.disable();
                    deviceControl.setMode(mode);
                    const cursor = mode === 'tap' ? 'crosshair' : 'grab';
                    canvas.style.cursor = cursor;
                }
            });
        });

        // Initialize overlay filters
        overlayFilters.init({
            clickable: 'filterClickable',
            nonClickable: 'filterNonClickable',
            textLabels: 'filterTextLabels',
            hideSmall: 'filterMinSize',
            textOnly: 'filterTextOnly'
        });

        // Handle connection type switching
        document.getElementById('connectionType').addEventListener('change', (e) => {
            const type = e.target.value;

            // Hide all config sections
            document.getElementById('tcpConfig').style.display = 'none';
            document.getElementById('pairingConfig').style.display = 'none';
            document.getElementById('wirelessConfig').style.display = 'none';
            document.getElementById('tlsConfig').style.display = 'none';

            // Show relevant config section
            switch(type) {
                case 'tcp':
                    document.getElementById('tcpConfig').style.display = 'block';
                    document.getElementById('devicePort').value = '5555';
                    break;
                case 'wireless':
                    document.getElementById('tcpConfig').style.display = 'block';
                    document.getElementById('wirelessConfig').style.display = 'block';
                    document.getElementById('devicePort').value = '5555';
                    break;
                case 'pairing':
                    // Pairing uses its own config, not TCP config
                    document.getElementById('pairingConfig').style.display = 'block';
                    break;
                case 'tls':
                    document.getElementById('tcpConfig').style.display = 'block';
                    document.getElementById('tlsConfig').style.display = 'block';
                    document.getElementById('devicePort').value = '5555';
                    break;
            }
        });

        // === Saved WiFi Devices (localStorage) ===
        const SAVED_DEVICES_KEY = 'visual_mapper_saved_devices';

        function getSavedDevices() {
            try {
                const saved = localStorage.getItem(SAVED_DEVICES_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('[Devices] Failed to load saved devices:', e);
                return [];
            }
        }

        function saveDevicesToStorage(devices) {
            try {
                localStorage.setItem(SAVED_DEVICES_KEY, JSON.stringify(devices));
            } catch (e) {
                console.error('[Devices] Failed to save devices:', e);
            }
        }

        function saveWifiDevice(deviceId, name = '') {
            // Parse IP:PORT from device ID
            const ipMatch = deviceId.match(/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)$/);
            if (!ipMatch) return false;

            const devices = getSavedDevices();
            const existing = devices.find(d => d.ip === ipMatch[1] && d.port === parseInt(ipMatch[2]));

            if (!existing) {
                devices.push({
                    ip: ipMatch[1],
                    port: parseInt(ipMatch[2]),
                    name: name || `Android (${ipMatch[1]})`,
                    lastConnected: new Date().toISOString(),
                    deviceId: deviceId
                });
                saveDevicesToStorage(devices);
                updateSavedDevicesList();
                return true;
            } else {
                // Update last connected time
                existing.lastConnected = new Date().toISOString();
                saveDevicesToStorage(devices);
                return false;
            }
        }

        function forgetSavedDevice(ip, port) {
            const devices = getSavedDevices();
            const filtered = devices.filter(d => !(d.ip === ip && d.port === port));
            saveDevicesToStorage(filtered);
            updateSavedDevicesList();
        }

        function updateSavedDevicesList() {
            const savedList = document.getElementById('savedDevicesList');
            const noDevicesMsg = document.getElementById('noSavedDevices');
            const devices = getSavedDevices();
            const connectedDevices = deviceManager.getDevices().map(d => d.id);

            if (devices.length === 0) {
                savedList.innerHTML = '';
                noDevicesMsg.style.display = 'block';
                return;
            }

            noDevicesMsg.style.display = 'none';

            const html = devices.map(device => {
                const deviceId = `${device.ip}:${device.port}`;
                const isConnected = connectedDevices.includes(deviceId);
                const lastConnected = device.lastConnected ? new Date(device.lastConnected).toLocaleDateString() : 'Never';

                return `
                    <div style="padding: 12px; border: 1px solid var(--border-color); margin-bottom: 8px; border-radius: 8px; background: var(--card-background); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <strong style="color: var(--text-color);">${device.name || deviceId}</strong>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${deviceId} ‚Ä¢ Last connected: ${lastConnected}
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            ${isConnected
                                ? '<span style="color: #4caf50; font-weight: bold; padding: 4px 8px;">‚óè Connected</span>'
                                : `<button onclick="window.reconnectSavedDevice('${device.ip}', ${device.port})" class="btn btn-primary btn-sm">Reconnect</button>`
                            }
                            <button onclick="window.forgetSavedDeviceHandler('${device.ip}', ${device.port})" class="btn btn-sm" style="background: #dc3545; color: white;">Forget</button>
                        </div>
                    </div>
                `;
            }).join('');

            savedList.innerHTML = html;
        }

        // Global handlers for saved devices
        window.reconnectSavedDevice = async (ip, port) => {
            const status = document.getElementById('connectionStatus');
            status.textContent = `Reconnecting to ${ip}:${port}...`;
            status.className = 'status';

            try {
                const response = await apiClient.post('/adb/connect', { host: ip, port: port });
                status.textContent = `‚úì Reconnected to ${ip}:${port}`;
                status.className = 'status success';

                // Update last connected time
                const devices = getSavedDevices();
                const device = devices.find(d => d.ip === ip && d.port === port);
                if (device) {
                    device.lastConnected = new Date().toISOString();
                    saveDevicesToStorage(devices);
                }

                await loadDevices();
            } catch (error) {
                status.textContent = `‚úó Reconnection failed: ${error.message}`;
                status.className = 'status error';
            }
        };

        window.forgetSavedDeviceHandler = (ip, port) => {
            if (confirm(`Forget saved device ${ip}:${port}? You can re-add it later.`)) {
                forgetSavedDevice(ip, port);
            }
        };

        window.saveDeviceHandler = (deviceId, model) => {
            const name = prompt('Enter a name for this device (optional):', model || '');
            if (name !== null) { // User didn't cancel
                saveWifiDevice(deviceId, name);
                updateDevicesList(); // Refresh to show "Saved" indicator
                const status = document.getElementById('connectionStatus');
                status.textContent = `‚úì Device saved for quick reconnection`;
                status.className = 'status success';
            }
        };

        // Load devices using DeviceManager
        async function loadDevices() {
            try {
                await deviceManager.loadDevices();
                updateDevicesList();
                updateDeviceSelect();
                updateSavedDevicesList(); // Also refresh saved devices status
            } catch (error) {
                console.error('[Devices] Failed to load devices:', error);
            }
        }

        // Update devices list UI
        function updateDevicesList() {
            const devicesList = document.getElementById('devicesList');
            const devices = deviceManager.getDevices();

            if (devices.length === 0) {
                devicesList.innerHTML = '<p class="status warning">No devices connected</p>';
                return;
            }

            const html = devices.map(device => {
                // Extract current IP:PORT from device ID for reconfigure
                const ipMatch = device.id.match(/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)$/);
                const isWifiDevice = ipMatch !== null;

                // Check if already saved
                const savedDevices = getSavedDevices();
                const isSaved = isWifiDevice && savedDevices.some(d => d.ip === ipMatch[1] && d.port === parseInt(ipMatch[2]));

                return `
                    <div style="padding: 15px; border: 1px solid var(--border-color); margin-bottom: 10px; border-radius: 8px; background: var(--card-background); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <strong style="color: var(--text-color);">${device.model || device.id}</strong>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${device.id} - ${device.state}
                                ${isSaved ? ' <span style="color: #4caf50;">‚òÖ Saved</span>' : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            ${isWifiDevice && !isSaved ? `<button onclick="window.saveDeviceHandler('${device.id}', '${device.model || ''}')" class="btn btn-secondary btn-sm" title="Save for quick reconnection">Save</button>` : ''}
                            ${isWifiDevice ? `<button onclick="window.reconfigureDeviceHandler('${device.id}')" class="btn btn-secondary btn-sm">Reconfigure</button>` : ''}
                            <button onclick="window.disconnectDeviceHandler('${device.id}')" class="btn btn-sm" style="background: #dc3545; color: white;">Disconnect</button>
                        </div>
                    </div>
                `;
            }).join('');

            devicesList.innerHTML = html;
        }

        // Update device select dropdown
        function updateDeviceSelect() {
            const select = document.getElementById('deviceSelect');
            const currentValue = select.value;
            const devices = deviceManager.getDevices();

            select.innerHTML = '<option value="">-- Select Device --</option>';

            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.id;

                // Show model and current activity
                let displayText = device.model || device.id;
                if (device.current_activity && device.current_activity !== 'Unknown' && device.current_activity !== 'Offline') {
                    const appName = device.current_activity.split('/')[0].split('.').pop() || '';
                    if (appName) {
                        displayText += ` - Active: ${appName}`;
                    }
                }

                option.textContent = displayText;
                select.appendChild(option);
            });

            // Restore selection if still valid
            if (currentValue && deviceManager.hasDevice(currentValue)) {
                select.value = currentValue;
                deviceManager.setSelectedDevice(currentValue);
                deviceControl.setDevice(currentValue);
            } else if (devices.length === 1) {
                // Auto-select if only one device
                select.value = devices[0].id;
                deviceManager.setSelectedDevice(devices[0].id);
                deviceControl.setDevice(devices[0].id);
            }
        }

        // Handle device selection changes
        document.getElementById('deviceSelect').addEventListener('change', (e) => {
            if (e.target.value) {
                deviceManager.setSelectedDevice(e.target.value);
                deviceControl.setDevice(e.target.value);
            }
        });

        // Connect device
        // === Network Device Discovery ===
        document.getElementById('scanNetworkBtn').addEventListener('click', async () => {
            const scanBtn = document.getElementById('scanNetworkBtn');
            const scanStatus = document.getElementById('scanStatus');
            const discoveredContainer = document.getElementById('discoveredDevicesContainer');
            const discoveredList = document.getElementById('discoveredDevicesList');
            const noDevicesFound = document.getElementById('noDevicesFound');

            try {
                // Disable button during scan
                scanBtn.disabled = true;
                scanBtn.textContent = 'üîç Scanning...';
                scanStatus.textContent = 'Scanning network for Android devices...';
                scanStatus.style.color = 'var(--text-secondary)';

                // Hide previous results
                discoveredContainer.style.display = 'none';
                noDevicesFound.style.display = 'none';

                // Call scan API
                const response = await apiClient.get('/adb/scan');

                console.log('[Network Scan] Found devices:', response);

                if (response.devices && response.devices.length > 0) {
                    // Show discovered devices
                    discoveredContainer.style.display = 'block';

                    let html = '<div style="display: grid; gap: 15px;">';

                    for (const device of response.devices) {
                        const androidVersion = device.android_version || 'Unknown';
                        const sdkVersion = device.sdk_version ? `(SDK ${device.sdk_version})` : '';
                        const model = device.model || 'Unknown Model';
                        const state = device.state === 'connected' ? 'Already Connected' : 'Available';
                        const stateColor = device.state === 'connected' ? 'var(--success-color)' : 'var(--text-secondary)';

                        // Recommendation badge
                        let recommendationBadge = '';
                        let recommendationText = '';
                        if (device.recommended_method === 'pairing') {
                            recommendationBadge = '<span style="background: #2196f3; color: white; padding: 3px 8px; border-radius: 4px; font-size: 12px; margin-left: 10px;">‚ö° Android 11+</span>';
                            recommendationText = '<p style="margin: 10px 0 5px 0; font-size: 13px; color: var(--text-secondary);">üì± <strong>Recommended:</strong> Use Wireless Pairing (Android 11+) for best security</p>';
                        } else {
                            recommendationBadge = '<span style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 4px; font-size: 12px; margin-left: 10px;">‚úì Legacy TCP</span>';
                            recommendationText = '<p style="margin: 10px 0 5px 0; font-size: 13px; color: var(--text-secondary);">üì± <strong>Recommended:</strong> Use TCP/IP Connection (Port 5555)</p>';
                        }

                        html += `
                            <div style="border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: var(--card-background);">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                    <div style="flex: 1;">
                                        <strong style="font-size: 16px;">${device.ip}:${device.port}</strong>
                                        ${recommendationBadge}
                                        <br>
                                        <span style="color: var(--text-secondary); font-size: 13px;">
                                            üì± ${model} | Android ${androidVersion} ${sdkVersion}
                                        </span>
                                        <br>
                                        <span style="color: ${stateColor}; font-size: 12px; font-weight: bold;">
                                            ${state}
                                        </span>
                                    </div>
                                </div>

                                ${recommendationText}

                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    ${device.state === 'connected' ? '' : `
                                        <button class="btn btn-primary quick-connect-btn"
                                                data-ip="${device.ip}"
                                                data-port="${device.port}"
                                                data-method="${device.recommended_method}"
                                                style="padding: 6px 12px; font-size: 13px;">
                                            ‚ö° Quick Connect (${device.recommended_method === 'pairing' ? 'Pairing' : 'TCP'})
                                        </button>
                                        ${device.recommended_method === 'pairing' ? `
                                            <button class="btn btn-secondary try-tcp-btn"
                                                    data-ip="${device.ip}"
                                                    data-port="${device.port}"
                                                    style="padding: 6px 12px; font-size: 13px;">
                                                üîÑ Try TCP Instead
                                            </button>
                                        ` : `
                                            <button class="btn btn-secondary try-pairing-btn"
                                                    data-ip="${device.ip}"
                                                    data-port="${device.port}"
                                                    style="padding: 6px 12px; font-size: 13px;">
                                                üîÑ Try Pairing Instead
                                            </button>
                                        `}
                                    `}
                                </div>
                            </div>
                        `;
                    }

                    html += '</div>';
                    discoveredList.innerHTML = html;

                    // Add event listeners for quick connect buttons
                    document.querySelectorAll('.quick-connect-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            const ip = e.target.dataset.ip;
                            const port = e.target.dataset.port;
                            const method = e.target.dataset.method;

                            if (method === 'pairing') {
                                // Pre-fill pairing form
                                document.getElementById('connectionType').value = 'pairing';
                                document.getElementById('connectionType').dispatchEvent(new Event('change'));
                                document.getElementById('pairingHost').value = ip;
                                alert('Please enable Wireless Debugging on your device and enter the pairing code and ports shown on the device.');
                            } else {
                                // Direct TCP connection
                                try {
                                    btn.disabled = true;
                                    btn.textContent = 'Connecting...';

                                    const response = await apiClient.post('/adb/connect', {
                                        host: ip,
                                        port: parseInt(port)
                                    });

                                    btn.textContent = '‚úì Connected!';
                                    btn.style.background = 'var(--success-color)';

                                    // Refresh device list
                                    setTimeout(() => loadDevices(), 500);
                                } catch (err) {
                                    btn.disabled = false;
                                    btn.textContent = '‚ùå Failed';
                                    alert('Connection failed: ' + (err.detail || err.message));
                                }
                            }
                        });
                    });

                    // Add event listeners for "Try alternative method" buttons
                    document.querySelectorAll('.try-tcp-btn, .try-pairing-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const ip = e.target.dataset.ip;
                            const port = e.target.dataset.port;
                            const isTryingPairing = e.target.classList.contains('try-pairing-btn');

                            if (isTryingPairing) {
                                // Switch to pairing mode
                                document.getElementById('connectionType').value = 'pairing';
                                document.getElementById('connectionType').dispatchEvent(new Event('change'));
                                document.getElementById('pairingHost').value = ip;
                                alert('Switched to Pairing mode. Please enable Wireless Debugging on your device and enter the pairing code and ports.');
                            } else {
                                // Switch to TCP mode
                                document.getElementById('connectionType').value = 'tcp';
                                document.getElementById('connectionType').dispatchEvent(new Event('change'));
                                document.getElementById('deviceHost').value = ip;
                                document.getElementById('devicePort').value = port;
                            }

                            // Scroll to connection form
                            document.querySelector('.card h2').scrollIntoView({ behavior: 'smooth' });
                        });
                    });

                    scanStatus.textContent = `‚úì Found ${response.devices.length} device(s) in ${response.scan_duration_ms}ms`;
                    scanStatus.style.color = 'var(--success-color)';
                } else {
                    // No devices found
                    noDevicesFound.style.display = 'block';
                    scanStatus.textContent = '‚úó No devices found on network';
                    scanStatus.style.color = 'var(--error-color)';
                }

            } catch (error) {
                console.error('[Network Scan] Error:', error);
                scanStatus.textContent = '‚úó Scan failed: ' + (error.detail || error.message);
                scanStatus.style.color = 'var(--error-color)';
            } finally {
                // Re-enable button
                scanBtn.disabled = false;
                scanBtn.textContent = 'üîç Scan Network';
            }
        });

        document.getElementById('connectBtn').addEventListener('click', async () => {
            const connectionType = document.getElementById('connectionType').value;
            const status = document.getElementById('connectionStatus');

            try {
                if (connectionType === 'pairing') {
                    // Wireless pairing flow (Android 11+)
                    const pairingCode = document.getElementById('pairingCode').value.trim();
                    const pairingHost = document.getElementById('pairingHost').value.trim();
                    const pairingPort = parseInt(document.getElementById('pairingPort').value);
                    const connectionPort = parseInt(document.getElementById('connectionPort').value);

                    if (!pairingCode || !pairingHost || !pairingPort || !connectionPort) {
                        status.textContent = 'Please fill in all pairing fields (code, IP, pairing port, and connection port)';
                        status.className = 'status error';
                        return;
                    }

                    if (pairingCode.length !== 6 || !/^\d+$/.test(pairingCode)) {
                        status.textContent = 'Pairing code must be exactly 6 digits';
                        status.className = 'status error';
                        return;
                    }

                    status.textContent = `Pairing with ${pairingHost}:${pairingPort}...`;
                    status.className = 'status';

                    // Call pairing API with both ports
                    const response = await apiClient.post('/adb/pair', {
                        pairing_host: pairingHost,
                        pairing_port: pairingPort,
                        pairing_code: pairingCode,
                        connection_port: connectionPort
                    });

                    status.textContent = `‚úì Paired and connected: ${response.device_id}`;
                    status.className = 'status success';

                    // Reload devices list
                    await loadDevices();

                } else {
                    // Standard TCP connection (legacy, wireless, or TLS)
                    const host = document.getElementById('deviceHost').value.trim();
                    const port = parseInt(document.getElementById('devicePort').value);

                    if (!host) {
                        status.textContent = 'Please enter device IP address';
                        status.className = 'status error';
                        return;
                    }

                    let connectionDesc = 'TCP/IP';
                    if (connectionType === 'wireless') {
                        connectionDesc = 'Wireless ADB (Android 11+)';
                    } else if (connectionType === 'tls') {
                        connectionDesc = 'TLS/Secure ADB';
                    }

                    status.textContent = `Connecting via ${connectionDesc} to ${host}:${port}...`;
                    status.className = 'status';

                    const response = await apiClient.connectDevice(host, port);

                    status.textContent = `‚úì Connected: ${response.device_id} (${connectionDesc})`;
                    status.className = 'status success';

                    // Reload devices list
                    await loadDevices();
                }

            } catch (error) {
                status.textContent = `‚úó Connection failed: ${error.message}`;
                status.className = 'status error';
            }
        });

        // Disconnect device handler (exposed globally for inline onclick)
        window.disconnectDeviceHandler = async (deviceId) => {
            try {
                await deviceManager.disconnect(deviceId);
                await loadDevices();
            } catch (error) {
                console.error('[Devices] Disconnect failed:', error);
                alert(`Disconnect failed: ${error.message}`);
            }
        };

        // Tab switching for reconfigure modal
        function switchConfigTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.config-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.style.borderBottom = '2px solid transparent';
                tab.style.color = 'var(--text-secondary)';
                tab.style.fontWeight = '400';
            });

            const activeTab = document.getElementById(`tab-${tabName}`);
            if (activeTab) {
                activeTab.classList.add('active');
                activeTab.style.borderBottom = '2px solid var(--primary-color)';
                activeTab.style.color = 'var(--primary-color)';
                activeTab.style.fontWeight = '600';
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(`content-${tabName}`);
            if (activeContent) {
                activeContent.style.display = 'block';
            }
        }

        // Attach tab click handlers
        document.getElementById('tab-connection').addEventListener('click', () => switchConfigTab('connection'));
        document.getElementById('tab-security').addEventListener('click', () => switchConfigTab('security'));

        // Reconfigure device handler
        let reconfigureOldDeviceId = null;

        window.reconfigureDeviceHandler = async (deviceId) => {
            // Parse current IP:PORT from device ID
            const ipMatch = deviceId.match(/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):?(\d+)?$/);
            if (!ipMatch) {
                alert('Cannot reconfigure this device type. Only WiFi (IP:PORT) devices can be reconfigured.');
                return;
            }

            const currentIp = ipMatch[1];
            const currentPort = ipMatch[2] || '5555';

            reconfigureOldDeviceId = deviceId;
            document.getElementById('reconfigureDeviceId').textContent = deviceId;
            document.getElementById('newDeviceHost').value = currentIp;
            document.getElementById('newDevicePort').value = currentPort;

            // Reset to connection tab
            switchConfigTab('connection');

            // Initialize security UI for this device with callbacks to close modal
            const securityContainer = document.getElementById('securityConfigContainer');
            if (securityContainer) {
                await deviceSecurityUI.initialize(deviceId, securityContainer, {
                    onSave: () => {
                        // Close modal after successful save
                        document.getElementById('reconfigureModal').style.display = 'none';
                        reconfigureOldDeviceId = null;
                    },
                    onCancel: () => {
                        // Close modal on cancel
                        document.getElementById('reconfigureModal').style.display = 'none';
                        reconfigureOldDeviceId = null;
                    }
                });
            }

            document.getElementById('reconfigureModal').style.display = 'flex';
        };

        // Reconfigure modal handlers
        document.getElementById('reconfigureCancel').addEventListener('click', () => {
            document.getElementById('reconfigureModal').style.display = 'none';
            reconfigureOldDeviceId = null;
        });

        document.getElementById('reconfigureConfirm').addEventListener('click', async () => {
            const newHost = document.getElementById('newDeviceHost').value.trim();
            const newPort = parseInt(document.getElementById('newDevicePort').value);

            if (!newHost || !newPort) {
                alert('Please enter a valid IP address and port');
                return;
            }

            const status = document.getElementById('connectionStatus');

            try {
                // Disconnect old device first
                if (reconfigureOldDeviceId) {
                    status.textContent = `Disconnecting ${reconfigureOldDeviceId}...`;
                    status.className = 'status';
                    try {
                        await deviceManager.disconnect(reconfigureOldDeviceId);
                    } catch (e) {
                        console.warn('[Devices] Disconnect during reconfigure:', e);
                    }
                }

                // Connect with new settings
                status.textContent = `Connecting to ${newHost}:${newPort}...`;
                await apiClient.post('/adb/connect', { host: newHost, port: newPort });

                status.textContent = `‚úì Reconnected to ${newHost}:${newPort}`;
                status.className = 'status success';

                document.getElementById('reconfigureModal').style.display = 'none';
                reconfigureOldDeviceId = null;

                // Reload devices
                await loadDevices();
            } catch (error) {
                status.textContent = `‚úó Reconfigure failed: ${error.message}`;
                status.className = 'status error';
            }
        });

        // Close modal on backdrop click
        document.getElementById('reconfigureModal').addEventListener('click', (e) => {
            if (e.target.id === 'reconfigureModal') {
                document.getElementById('reconfigureModal').style.display = 'none';
                reconfigureOldDeviceId = null;
            }
        });

        // Manual screenshot capture (uses AutoRefresh.captureNow for consistency)
        let isManualCaptureInProgress = false;  // Prevent double-clicks

        async function captureScreenshot() {
            // Prevent duplicate calls
            if (isManualCaptureInProgress) {
                console.log('[Devices] Capture already in progress, ignoring duplicate click');
                return;
            }

            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('screenshotStatus');

            if (!deviceId) {
                status.textContent = 'Please select a device';
                status.className = 'status error';
                return;
            }

            isManualCaptureInProgress = true;
            status.textContent = 'Capturing screenshot...';
            status.className = 'status';

            try {
                await autoRefresh.captureNow(deviceId, (success, result) => {
                    if (success) {
                        status.textContent = `‚úì Screenshot captured: ${result.elements.length} UI elements detected`;
                        status.className = 'status success';
                    } else {
                        status.textContent = `‚úó Capture failed: ${result.message || result}`;
                        status.className = 'status error';
                    }
                });
            } finally {
                // Always release lock
                isManualCaptureInProgress = false;
            }
        }

        // Manual capture button
        document.getElementById('captureBtn').addEventListener('click', captureScreenshot);

        // Manual refresh button
        document.getElementById('refreshBtn').addEventListener('click', captureScreenshot);

        // Auto-refresh toggle
        document.getElementById('autoRefreshToggle').addEventListener('change', (e) => {
            if (e.target.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        });

        // Refresh interval change
        document.getElementById('refreshInterval').addEventListener('change', () => {
            if (document.getElementById('autoRefreshToggle').checked) {
                // Restart with new interval
                stopAutoRefresh();
                startAutoRefresh();
            }
        });

        // Smart refresh (activity monitor) toggle
        document.getElementById('smartRefreshToggle').addEventListener('change', (e) => {
            if (e.target.checked) {
                startSmartRefresh();
            } else {
                stopSmartRefresh();
            }
        });

        function startAutoRefresh() {
            const interval = parseInt(document.getElementById('refreshInterval').value);
            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('screenshotStatus');

            if (!deviceId) {
                status.textContent = 'Please select a device first';
                status.className = 'status error';
                document.getElementById('autoRefreshToggle').checked = false;
                return;
            }

            status.textContent = `üîÑ Auto-refresh enabled (every ${interval/1000}s)`;
            status.className = 'status';

            autoRefresh.start(interval, deviceId, (success, result) => {
                if (success) {
                    const now = new Date().toLocaleTimeString();
                    status.textContent = `üîÑ Auto-refresh: ${result.elements.length} elements (${now})`;
                    status.className = 'status';
                } else {
                    status.textContent = `‚úó Auto-refresh failed: ${result.message}`;
                    status.className = 'status error';
                }
            });
        }

        function stopAutoRefresh() {
            autoRefresh.stop();

            const status = document.getElementById('screenshotStatus');
            status.textContent = 'Auto-refresh stopped';
            status.className = 'status';
        }

        async function startSmartRefresh() {
            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('screenshotStatus');

            if (!deviceId) {
                status.textContent = 'Please select a device first';
                status.className = 'status error';
                document.getElementById('smartRefreshToggle').checked = false;
                return;
            }

            // Use ActivityMonitor's smart refresh method (includes retry logic)
            await activityMonitor.startSmartRefresh(
                deviceId,
                (devId) => screenshotCapture.capture(devId), // Capture function
                (elementCount, timestamp) => {
                    // Success callback
                    status.textContent = `‚ö° Smart refresh: ${elementCount} elements (${timestamp})`;
                    status.className = 'status';
                }
            );
        }

        function stopSmartRefresh() {
            activityMonitor.stop();
        }

        // Send text to device
        document.getElementById('sendTextBtn').addEventListener('click', async () => {
            const text = document.getElementById('textInput').value;
            const status = document.getElementById('screenshotStatus');

            if (!text) {
                status.textContent = 'Please enter text to send';
                status.className = 'status error';
                return;
            }

            try {
                status.textContent = 'Typing text on device...';
                status.className = 'status';

                await deviceControl.typeText(text);

                status.textContent = `‚úì Typed ${text.length} characters`;
                status.className = 'status success';

                // Clear input
                document.getElementById('textInput').value = '';

            } catch (error) {
                status.textContent = `‚úó Text input failed: ${error.message}`;
                status.className = 'status error';
            }
        });

        // Hardware key event helper
        async function sendKeyEvent(keycode, keyName) {
            const deviceId = document.getElementById('deviceSelect').value;
            const status = document.getElementById('screenshotStatus');

            if (!deviceId) {
                status.textContent = 'Please select a device';
                status.className = 'status error';
                return;
            }

            try {
                status.textContent = `Sending ${keyName}...`;
                status.className = 'status';

                await apiClient.post('/adb/keyevent', {
                    device_id: deviceId,
                    keycode: keycode
                });

                status.textContent = `‚úì Sent ${keyName}`;
                status.className = 'status success';

            } catch (error) {
                status.textContent = `‚úó ${keyName} failed: ${error.message}`;
                status.className = 'status error';
            }
        }

        // Hardware key buttons
        document.getElementById('homeBtn').addEventListener('click', () => sendKeyEvent('KEYCODE_HOME', 'Home'));
        document.getElementById('backBtn').addEventListener('click', () => sendKeyEvent('KEYCODE_BACK', 'Back'));
        document.getElementById('recentBtn').addEventListener('click', () => sendKeyEvent('KEYCODE_APP_SWITCH', 'Recent Apps'));
        document.getElementById('volumeUpBtn').addEventListener('click', () => sendKeyEvent('KEYCODE_VOLUME_UP', 'Volume Up'));
        document.getElementById('volumeDownBtn').addEventListener('click', () => sendKeyEvent('KEYCODE_VOLUME_DOWN', 'Volume Down'));

        // App Launcher functionality
        let allApps = [];
        let filteredApps = [];

        async function loadApps() {
            const deviceId = document.getElementById('deviceSelect').value;
            const appSelect = document.getElementById('appSelect');
            const status = document.getElementById('appLauncherStatus');

            if (!deviceId) {
                appSelect.innerHTML = '<option value="">Select device above and click \'Load Apps\'...</option>';
                allApps = [];
                filteredApps = [];
                status.textContent = '‚ùå Please select a device from the dropdown above';
                status.className = 'status error';
                return;
            }

            try {
                status.textContent = 'Loading apps...';
                status.className = 'status';

                const response = await apiClient.get(`/adb/apps/${deviceId}`);
                allApps = response.apps || [];

                if (allApps.length === 0) {
                    status.textContent = '‚ùå No apps found on device. Device may be offline or ADB permissions denied.';
                    status.className = 'status error';
                    appSelect.innerHTML = '<option value="">No apps available</option>';
                    return;
                }

                console.log(`[AppLauncher] Loaded ${allApps.length} apps for ${deviceId}`);

                // Apply filters
                filterAndDisplayApps();

                const filteredCount = filteredApps.length;
                status.textContent = `‚úÖ Loaded ${allApps.length} apps (${filteredCount} shown after filters)`;
                status.className = 'status success';
            } catch (error) {
                console.error('[AppLauncher] Failed to load apps:', error);
                status.textContent = `‚ùå Failed to load apps: ${error.message}. Check device connection and ADB permissions.`;
                status.className = 'status error';
                appSelect.innerHTML = '<option value="">Failed to load apps</option>';
                allApps = [];
                filteredApps = [];
            }
        }

        function filterAndDisplayApps() {
            const appSelect = document.getElementById('appSelect');
            const searchResultsDiv = document.getElementById('appSearchResults');
            const showSystem = document.getElementById('showSystemApps').checked;
            const searchTerm = document.getElementById('appSearch').value.toLowerCase();
            const status = document.getElementById('appLauncherStatus');

            // Filter apps
            filteredApps = allApps.filter(app => {
                // System app filter
                if (!showSystem && app.is_system) {
                    return false;
                }

                // Search filter
                if (searchTerm) {
                    return app.package.toLowerCase().includes(searchTerm) ||
                           app.label.toLowerCase().includes(searchTerm);
                }

                return true;
            });

            // Sort by label
            filteredApps.sort((a, b) => a.label.localeCompare(b.label));

            // Show live search results preview (only when searching)
            if (searchTerm && allApps.length > 0) {
                searchResultsDiv.style.display = 'block';

                if (filteredApps.length === 0) {
                    searchResultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: var(--text-secondary);">No apps match your search</div>';
                } else {
                    // Show first 10 results as clickable list
                    const resultsToShow = filteredApps.slice(0, 10);
                    let resultsHtml = `<div style="padding: 8px; background: var(--preview-background); border-bottom: 1px solid var(--border-color); font-weight: bold;">Found ${filteredApps.length} app${filteredApps.length !== 1 ? 's' : ''} matching "${searchTerm}"</div>`;

                    resultsToShow.forEach(app => {
                        const systemBadge = app.is_system ? '<span style="background: #9E9E9E; color: white; padding: 1px 5px; border-radius: 2px; font-size: 10px; margin-left: 5px;">SYSTEM</span>' : '';
                        resultsHtml += `
                            <div style="padding: 10px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;"
                                 onmouseover="this.style.background='var(--preview-background)'"
                                 onmouseout="this.style.background='var(--card-background)'"
                                 onclick="window.selectAndLaunchApp('${app.package}')">
                                <div style="font-weight: bold;">${app.label}${systemBadge}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${app.package}</div>
                            </div>
                        `;
                    });

                    if (filteredApps.length > 10) {
                        resultsHtml += `<div style="padding: 10px; text-align: center; color: var(--text-secondary); font-size: 12px;">... and ${filteredApps.length - 10} more</div>`;
                    }

                    searchResultsDiv.innerHTML = resultsHtml;
                }
            } else {
                searchResultsDiv.style.display = 'none';
            }

            // Populate dropdown
            if (filteredApps.length === 0) {
                appSelect.innerHTML = '<option value="">No apps match your filters</option>';
                if (allApps.length > 0 && !searchTerm) {
                    status.textContent = `‚ö†Ô∏è No apps match filters. Total apps: ${allApps.length}`;
                    status.className = 'status warning';
                } else if (searchTerm) {
                    status.textContent = '';
                }
                return;
            }

            // Show filter results in placeholder with count
            const placeholderText = searchTerm
                ? `-- Found ${filteredApps.length} app${filteredApps.length !== 1 ? 's' : ''} matching "${searchTerm}" --`
                : `-- Select an app to launch (${filteredApps.length} available) --`;

            appSelect.innerHTML = `<option value="">${placeholderText}</option>`;

            filteredApps.forEach(app => {
                const option = document.createElement('option');
                option.value = app.package;
                option.textContent = `${app.label} (${app.package})`;
                appSelect.appendChild(option);
            });

            // Update status with filter count (only when not searching, since results box shows it)
            if (!searchTerm && allApps.length > 0 && filteredApps.length !== allApps.length) {
                status.textContent = `‚úÖ Showing ${filteredApps.length} of ${allApps.length} apps`;
                status.className = 'status success';
            } else if (!searchTerm) {
                status.textContent = '';
            }
        }

        async function launchApp() {
            const deviceId = document.getElementById('deviceSelect').value;
            const packageName = document.getElementById('appSelect').value;
            const status = document.getElementById('appLauncherStatus');

            if (!deviceId) {
                status.textContent = '‚ùå Please select a device from the dropdown above';
                status.className = 'status error';
                return;
            }

            if (!packageName) {
                status.textContent = '‚ùå Please select an app to launch';
                status.className = 'status error';
                return;
            }

            try {
                status.textContent = `Launching ${packageName}...`;
                status.className = 'status';

                const response = await apiClient.post('/adb/launch', {
                    device_id: deviceId,
                    package: packageName
                });

                if (response.success) {
                    // Get the app label for better feedback
                    const app = allApps.find(a => a.package === packageName);
                    const appLabel = app ? app.label : packageName;

                    status.textContent = `‚úÖ Launched ${appLabel}`;
                    status.className = 'status success';
                    console.log(`[AppLauncher] Launched ${packageName} on ${deviceId}`);
                } else {
                    status.textContent = `‚ùå Failed to launch app. App may not support launching or device is offline.`;
                    status.className = 'status error';
                }
            } catch (error) {
                console.error('[AppLauncher] Failed to launch app:', error);
                status.textContent = `‚ùå Failed to launch app: ${error.message}. Device may be offline.`;
                status.className = 'status error';
            }
        }

        // Helper function to select and launch app from search results
        window.selectAndLaunchApp = async function(packageName) {
            const appSelect = document.getElementById('appSelect');
            appSelect.value = packageName;
            await launchApp();
        };

        // Smart search - auto-load apps when user starts typing
        document.getElementById('appSearch').addEventListener('input', async (e) => {
            const searchTerm = e.target.value.trim();

            // If user is typing but apps haven't been loaded yet, auto-load them
            if (searchTerm && allApps.length === 0) {
                const deviceId = document.getElementById('deviceSelect').value;
                if (deviceId) {
                    // Auto-load apps in background
                    await loadApps();
                } else {
                    // Show message that device needs to be selected
                    const searchResultsDiv = document.getElementById('appSearchResults');
                    searchResultsDiv.style.display = 'block';
                    searchResultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: var(--text-secondary);">‚ö†Ô∏è Please select a device above first</div>';
                }
            } else {
                // Normal filtering
                filterAndDisplayApps();
            }
        });

        // App launcher event listeners
        document.getElementById('showSystemApps').addEventListener('change', filterAndDisplayApps);
        document.getElementById('refreshAppsBtn').addEventListener('click', loadApps);
        document.getElementById('launchAppBtn').addEventListener('click', launchApp);

        // Action Creator - Simple prompt-based action creation
        async function showActionCreator(deviceId, element, elementIndex) {
            const status = document.getElementById('screenshotStatus');

            // Get center coordinates of the selected element
            // Handle both bounds object format and direct coordinate properties
            let centerX, centerY;

            if (element.bounds && typeof element.bounds === 'object') {
                // Bounds object format: {x, y, width, height}
                centerX = Math.round(element.bounds.x + element.bounds.width / 2);
                centerY = Math.round(element.bounds.y + element.bounds.height / 2);
            } else if (element.x !== undefined && element.y !== undefined) {
                // Direct coordinate format
                centerX = Math.round(element.x + (element.width || 0) / 2);
                centerY = Math.round(element.y + (element.height || 0) / 2);
            } else {
                // Fallback: use element position if available
                console.error('[ActionCreator] Element has invalid bounds:', element);
                status.textContent = '‚úó Cannot create action: element bounds are invalid';
                status.className = 'status error';
                return;
            }

            // Validate coordinates are numbers
            if (isNaN(centerX) || isNaN(centerY)) {
                console.error('[ActionCreator] Invalid coordinates:', { centerX, centerY, element });
                status.textContent = '‚úó Cannot create action: invalid coordinates';
                status.className = 'status error';
                return;
            }

            // Prompt for action name
            const actionName = prompt(
                `Create Action for Element:\n\n` +
                `Text: ${element.text || 'N/A'}\n` +
                `Class: ${element.class || 'N/A'}\n` +
                `Position: (${centerX}, ${centerY})\n\n` +
                `Enter action name:`
            );

            if (!actionName || actionName.trim() === '') {
                status.textContent = 'Action creation cancelled';
                status.className = 'status';
                return;
            }

            try {
                status.textContent = 'Creating tap action...';
                status.className = 'status';

                // Set device ID on action manager
                actionManager.setDevice(deviceId);

                // Create tap action
                const actionConfig = {
                    action_type: 'tap',
                    name: actionName.trim(),
                    description: `Tap on "${element.text || element.class}" at (${centerX}, ${centerY})`,
                    device_id: deviceId,
                    x: centerX,
                    y: centerY,
                    enabled: true
                };

                const tags = [element.class ? `class:${element.class}` : 'ui-element'];

                const result = await actionManager.createAction(actionConfig, tags);

                status.textContent = `‚úì Action "${actionName.trim()}" created successfully! View it on the Actions page.`;
                status.className = 'status success';

                console.log('[ActionCreator] Created action:', result);

                // Switch back to tap mode
                document.getElementById('modeTap').checked = true;
                document.getElementById('modeTap').dispatchEvent(new Event('change'));

            } catch (error) {
                console.error('[ActionCreator] Failed to create action:', error);
                status.textContent = `‚úó Failed to create action: ${error.message}`;
                status.className = 'status error';
            }
        }

        // ========== Icon Management (Phase 8 Enhancement) ==========

        // Helper function to get API base
        const getApiBase = () => '/api';

        // Check Icon Cache Button
        document.getElementById('checkIconCacheBtn').addEventListener('click', async () => {
            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('iconMgmtStatus');
            const cacheStatusDiv = document.getElementById('iconCacheStatus');

            if (!deviceId) {
                status.textContent = 'Please select a device first';
                status.className = 'status error';
                return;
            }

            status.textContent = 'Checking icon cache...';
            status.className = 'status';
            cacheStatusDiv.style.display = 'none';

            try {
                const response = await fetch(`${getApiBase()}/adb/check-icon-cache/${encodeURIComponent(deviceId)}`);
                const data = await response.json();

                // Update cache status display
                document.getElementById('iconCount').textContent = data.cache_stats?.total_icons || 0;
                document.getElementById('cacheSize').textContent = data.cache_stats?.total_size_mb ? `${data.cache_stats.total_size_mb} MB` : '0 MB';
                document.getElementById('newAppsCount').textContent = data.new_apps_count || 0;

                cacheStatusDiv.style.display = 'block';

                if (data.needs_update) {
                    status.textContent = `‚ö†Ô∏è ${data.new_apps_count} new app(s) detected. Click "Scrape Device Icons" to update cache.`;
                    status.className = 'status warning';
                } else {
                    status.textContent = `‚úÖ Icon cache is up to date (${data.cache_stats?.total_icons || 0} icons cached)`;
                    status.className = 'status success';
                }
            } catch (error) {
                console.error('Failed to check icon cache:', error);
                status.textContent = `‚úó Failed to check icon cache: ${error.message}`;
                status.className = 'status error';
            }
        });

        // Scrape Device Icons Button
        document.getElementById('scrapeIconsBtn').addEventListener('click', async () => {
            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('iconMgmtStatus');
            const progressDiv = document.getElementById('iconScrapeProgress');
            const progressText = document.getElementById('scrapeProgressText');
            const progressDetail = document.getElementById('scrapeProgressDetail');

            if (!deviceId) {
                status.textContent = 'Please select a device first';
                status.className = 'status error';
                return;
            }

            // Confirm action
            if (!confirm('This will scrape app icons from the device app drawer. It may take 30-60 seconds. Continue?')) {
                return;
            }

            status.textContent = '';
            progressDiv.style.display = 'block';
            progressText.textContent = 'Scraping device icons...';
            progressDetail.textContent = 'Opening app drawer and capturing screenshots...';

            try {
                const response = await fetch(`${getApiBase()}/adb/scrape-device-icons/${encodeURIComponent(deviceId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                progressDiv.style.display = 'none';

                if (data.success) {
                    status.textContent = `‚úÖ Successfully scraped ${data.icons_scraped} icons! Cache size: ${data.cache_stats?.total_size_mb || 0} MB`;
                    status.className = 'status success';

                    // Update cache status display
                    document.getElementById('iconCount').textContent = data.cache_stats?.total_icons || 0;
                    document.getElementById('cacheSize').textContent = data.cache_stats?.total_size_mb ? `${data.cache_stats.total_size_mb} MB` : '0 MB';
                    document.getElementById('newAppsCount').textContent = 0;
                    document.getElementById('iconCacheStatus').style.display = 'block';
                } else {
                    status.textContent = `‚úó Icon scraping failed`;
                    status.className = 'status error';
                }
            } catch (error) {
                console.error('Failed to scrape device icons:', error);
                progressDiv.style.display = 'none';
                status.textContent = `‚úó Failed to scrape icons: ${error.message}`;
                status.className = 'status error';
            }
        });

        // View Cache Stats Button
        document.getElementById('viewCacheStatsBtn').addEventListener('click', async () => {
            const deviceId = deviceManager.getSelectedDevice();
            const status = document.getElementById('iconMgmtStatus');

            status.textContent = 'Loading cache statistics...';
            status.className = 'status';

            try {
                const url = deviceId
                    ? `${getApiBase()}/adb/icon-cache-stats?device_id=${encodeURIComponent(deviceId)}`
                    : `${getApiBase()}/adb/icon-cache-stats`;

                const response = await fetch(url);
                const stats = await response.json();

                // Format stats for display
                let statsText = 'üìä Icon Cache Statistics:\n\n';

                if (stats.device_scraper) {
                    statsText += `Device-Specific Icons:\n`;
                    statsText += `  ‚Ä¢ Icons: ${stats.device_scraper.total_icons || 0}\n`;
                    statsText += `  ‚Ä¢ Size: ${stats.device_scraper.total_size_mb || 0} MB\n\n`;
                }

                if (stats.playstore_scraper) {
                    statsText += `Play Store Icons:\n`;
                    statsText += `  ‚Ä¢ Icons: ${stats.playstore_scraper.total_icons || 0}\n`;
                    statsText += `  ‚Ä¢ Size: ${stats.playstore_scraper.total_size_mb || 0} MB\n\n`;
                }

                if (stats.apk_extractor) {
                    statsText += `APK Extracted Icons:\n`;
                    statsText += `  ‚Ä¢ Icons: ${stats.apk_extractor.total_icons || 0}\n`;
                    statsText += `  ‚Ä¢ Size: ${stats.apk_extractor.total_size_mb || 0} MB\n`;
                }

                alert(statsText);
                status.textContent = '‚úÖ Statistics loaded';
                status.className = 'status success';
            } catch (error) {
                console.error('Failed to load cache stats:', error);
                status.textContent = `‚úó Failed to load stats: ${error.message}`;
                status.className = 'status error';
            }
        });

        // Initial load
        loadDevices();
    </script>
</body>
</html>
