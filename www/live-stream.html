<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="0.0.5">
    <meta name="version" content="0.0.5" data-build="2025-12-27">
    <title>Live Stream - Visual Mapper</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="css/styles.css?v=0.0.5">
    <link rel="stylesheet" href="css/live-stream.css?v=0.0.5">
</head>
<body>
    <nav>
        <ul>
            <li class="nav-priority-high"><a href="main.html">Dashboard</a></li>
            <li class="nav-priority-high"><a href="devices.html">Devices</a></li>
            <li class="nav-priority-high"><a href="sensors.html">Sensors</a></li>
            <li class="nav-priority-med"><a href="actions.html">Actions</a></li>
            <li class="nav-priority-med"><a href="flows.html">Flows</a></li>
            <li class="nav-priority-med"><a href="diagnostic.html">Diagnostics</a></li>
            <li class="nav-priority-low"><a href="live-stream.html" class="active">Live Stream</a></li>
            <li class="nav-priority-low"><a href="dev.html">Dev Tools</a></li>
            <li class="version">v0.0.5</li>
        </ul>
    </nav>

    <div class="container">
        <div class="card">
            <h1>Live Stream POC</h1>
            <p>Real-time screenshot streaming via WebSocket (~5 FPS)</p>
        </div>

        <div class="card">
            <h2>Stream Controls</h2>

            <div class="controls-row">
                <div class="control-group">
                    <label for="deviceSelect">Device:</label>
                    <select id="deviceSelect">
                        <option value="">-- Select Device --</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="streamMode">Mode:</label>
                    <select id="streamMode">
                        <option value="mjpeg" selected>MJPEG Binary (Recommended)</option>
                        <option value="websocket">WebSocket Base64</option>
                        <option value="scrcpy">scrcpy (High FPS - 30-60fps)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="streamQuality">Quality:</label>
                    <select id="streamQuality">
                        <option value="high">High (Native) ~5 FPS</option>
                        <option value="medium" selected>Medium (720p) ~10 FPS</option>
                        <option value="low">Low (480p) ~15 FPS</option>
                        <option value="fast">Fast (360p) ~20 FPS</option>
                    </select>
                </div>

                <div class="control-group">
                    <button id="startBtn" class="btn btn-primary">Start Stream</button>
                    <button id="stopBtn" class="btn btn-secondary" disabled>Stop Stream</button>
                    <button id="refreshDevicesBtn" class="btn">Refresh Devices</button>
                </div>
            </div>

            <div class="controls-row">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="showOverlays" checked>
                        Show Element Overlays
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="showLabels" checked>
                        Show Text Labels
                    </label>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Element Overlay Controls</h2>
            <div class="controls-row">
                <div class="control-group">
                    <button id="refreshElementsBtn" class="btn btn-primary">Refresh Elements</button>
                    <label style="margin-left: 15px;">
                        <input type="checkbox" id="autoRefreshElements">
                        Auto-refresh every
                    </label>
                    <select id="autoRefreshInterval" style="margin-left: 5px;">
                        <option value="2000">2s</option>
                        <option value="5000" selected>5s</option>
                        <option value="10000">10s</option>
                        <option value="30000">30s</option>
                    </select>
                </div>
            </div>
            <div class="controls-row">
                <span id="elementStatus" class="element-status">No elements loaded</span>
            </div>
            <div class="controls-row">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="filterClickable">
                        Clickable Only
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="filterWithText">
                        With Text Only
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="filterLargeElements" checked>
                        Hide Small Elements (&lt;20px)
                    </label>
                </div>
            </div>
        </div>

        <div class="card" id="selectedElementCard" style="display: none;">
            <h2>Selected Element</h2>
            <div class="element-details">
                <div class="detail-row">
                    <span class="detail-label">Class:</span>
                    <span id="elClass" class="detail-value">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Text:</span>
                    <span id="elText" class="detail-value">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Resource ID:</span>
                    <span id="elResourceId" class="detail-value">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Content Desc:</span>
                    <span id="elContentDesc" class="detail-value">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Bounds:</span>
                    <span id="elBounds" class="detail-value">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Clickable:</span>
                    <span id="elClickable" class="detail-value">-</span>
                </div>
            </div>
            <div class="controls-row" style="margin-top: 15px;">
                <button id="createActionBtn" class="btn btn-primary">Create Action</button>
                <button id="clearSelectionBtn" class="btn btn-secondary">Clear Selection</button>
            </div>
        </div>

        <!-- Create Action Dialog -->
        <div id="createActionDialog" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h2>Create Action</h2>
                <div class="form-group">
                    <label for="actionName">Action Name:</label>
                    <input type="text" id="actionName" class="form-control" placeholder="Enter action name">
                </div>
                <div class="form-group">
                    <label for="actionDescription">Description:</label>
                    <input type="text" id="actionDescription" class="form-control" placeholder="Optional description">
                </div>
                <div class="form-group">
                    <label for="actionType">Action Type:</label>
                    <select id="actionType" class="form-control">
                        <option value="tap">Tap</option>
                        <option value="swipe">Swipe</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Coordinates:</label>
                    <div class="coords-display">
                        <span>X: <input type="number" id="actionX" class="form-control-sm" style="width: 80px;"></span>
                        <span>Y: <input type="number" id="actionY" class="form-control-sm" style="width: 80px;"></span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="actionTags">Tags (comma-separated):</label>
                    <input type="text" id="actionTags" class="form-control" placeholder="e.g., navigation, control">
                </div>
                <div class="modal-info" id="actionElementInfo"></div>
                <div class="modal-buttons">
                    <button id="saveActionBtn" class="btn btn-primary">Save Action</button>
                    <button id="cancelActionBtn" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Performance Metrics</h2>
            <div class="metrics-grid">
                <div class="metric">
                    <span class="metric-label">Status:</span>
                    <span id="statusValue" class="metric-value status-disconnected">Disconnected</span>
                </div>
                <div class="metric">
                    <span class="metric-label">FPS:</span>
                    <span id="fpsValue" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Latency:</span>
                    <span id="latencyValue" class="metric-value">0 ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Capture Time:</span>
                    <span id="captureValue" class="metric-value">0 ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Frames:</span>
                    <span id="frameValue" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Elements:</span>
                    <span id="elementsValue" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Bandwidth:</span>
                    <span id="bandwidthValue" class="metric-value">0 KB/s</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Mode:</span>
                    <span id="streamModeValue" class="metric-value">--</span>
                </div>
            </div>
        </div>

        <div class="card stream-card">
            <h2>Stream View</h2>

            <!-- Quick Actions Bar -->
            <div id="quickActionsBar" class="quick-actions-bar">
                <button class="quick-btn" id="qabRefresh" title="Refresh Elements">
                    <span class="quick-icon">‚Üª</span>
                </button>
                <button class="quick-btn" id="qabBack" title="Back">
                    <span class="quick-icon">‚Üê</span>
                </button>
                <button class="quick-btn" id="qabHome" title="Home">
                    <span class="quick-icon">‚óè</span>
                </button>
                <button class="quick-btn" id="qabRecent" title="Recent Apps">
                    <span class="quick-icon">‚ñ¢</span>
                </button>
                <div class="quick-divider"></div>
                <button class="quick-btn" id="qabZoomIn" title="Zoom In">
                    <span class="quick-icon">+</span>
                </button>
                <button class="quick-btn" id="qabZoomOut" title="Zoom Out">
                    <span class="quick-icon">‚àí</span>
                </button>
                <button class="quick-btn" id="qabZoomReset" title="Reset Zoom (1:1)">
                    <span class="quick-icon">1:1</span>
                </button>
                <span id="zoomLevel" class="zoom-level">100%</span>
                <div class="quick-divider"></div>
                <span id="connectionStatus" class="connection-status disconnected" title="Connection Status">
                    <span class="status-dot"></span>
                    <span class="status-text">Disconnected</span>
                </span>
                <div class="quick-divider"></div>
                <button class="quick-btn" id="qabScreenshot" title="Save Screenshot">
                    <span class="quick-icon">üì∑</span>
                </button>
                <button class="quick-btn" id="qabFullscreen" title="Toggle Fullscreen">
                    <span class="quick-icon">‚õ∂</span>
                </button>
                <button class="quick-btn" id="qabSplitView" title="Toggle Split View">
                    <span class="quick-icon">‚ó´</span>
                </button>
            </div>

            <div id="splitViewContainer" class="split-view-container">
                <div id="canvasContainer" class="canvas-container">
                    <canvas id="streamCanvas"></canvas>
                    <div id="tapIndicator" class="tap-indicator" style="display: none;"></div>
                    <div id="swipePathContainer" class="swipe-path" style="display: none;"></div>
                    <div id="hoverTooltip" class="hover-tooltip" style="display: none;">
                        <div class="tooltip-header"></div>
                        <div class="tooltip-body"></div>
                    </div>
                    <div id="noStream" class="no-stream-overlay">
                        <p>Select a device and click "Start Stream"</p>
                    </div>
                </div>

                <!-- Element Tree Panel (Split View) -->
                <div id="elementTreePanel" class="element-tree-panel" style="display: none;">
                    <div class="tree-header">
                        <h3>Element Tree</h3>
                        <input type="text" id="treeSearch" class="tree-search" placeholder="Search elements...">
                    </div>
                    <div id="elementTreeContent" class="tree-content">
                        <p class="tree-empty">Click "Refresh Elements" to load</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Touch Controls</h2>
            <p><strong>Click</strong> = Tap &nbsp;|&nbsp; <strong>Click + Drag</strong> = Swipe</p>
            <div id="lastTap" class="tap-info">Last action: --</div>
        </div>

        <div class="card">
            <h2>Gesture Recording</h2>
            <div class="controls-row">
                <button id="recordBtn" class="btn btn-record">Start Recording</button>
                <button id="clearRecordingBtn" class="btn btn-secondary" disabled>Clear</button>
                <button id="saveRecordingBtn" class="btn btn-primary" disabled>Save as Flow</button>
            </div>
            <div id="recordingStatus" class="recording-status">
                <span id="recordingIndicator" class="recording-indicator"></span>
                <span id="recordingText">Not recording</span>
            </div>
            <div id="recordedActions" class="recorded-actions">
                <p class="empty-message">No actions recorded. Click "Start Recording" and interact with the device.</p>
            </div>
        </div>

        <div class="card">
            <h2>Navigation Controls</h2>
            <div class="nav-controls">
                <div class="nav-row">
                    <button id="btnBack" class="nav-btn" title="Back">&#x2190; Back</button>
                    <button id="btnHome" class="nav-btn" title="Home">&#x25CF; Home</button>
                    <button id="btnRecent" class="nav-btn" title="Recent Apps">&#x25A1; Recent</button>
                </div>
                <div class="nav-row">
                    <button id="btnSwipeUp" class="nav-btn" title="Swipe Up">&#x2191; Swipe Up</button>
                    <button id="btnSwipeDown" class="nav-btn" title="Swipe Down">&#x2193; Swipe Down</button>
                </div>
                <div class="nav-row">
                    <button id="btnSwipeLeft" class="nav-btn" title="Swipe Left">&#x2190; Swipe Left</button>
                    <button id="btnSwipeRight" class="nav-btn" title="Swipe Right">&#x2192; Swipe Right</button>
                </div>
            </div>
            <div id="lastAction" class="tap-info">Last action: --</div>
        </div>
    </div>

    <script type="module">
        import LiveStream from './js/modules/live-stream.js?v=0.0.15';
        import ActionManager from './js/modules/action-manager.js?v=0.0.6';

        // API helper
        function getApiBase() {
            const url = window.location.href;
            const ingressMatch = url.match(/\/api\/hassio_ingress\/[^\/]+/);
            if (ingressMatch) {
                return ingressMatch[0] + '/api';
            }
            return '/api';
        }

        async function apiGet(endpoint) {
            const response = await fetch(getApiBase() + endpoint);
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            return response.json();
        }

        async function apiPost(endpoint, data) {
            const response = await fetch(getApiBase() + endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            return response.json();
        }

        // API client wrapper for ActionManager
        const apiClient = {
            get: async (endpoint) => {
                const response = await fetch(getApiBase() + endpoint);
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                return response.json();
            },
            post: async (endpoint, data) => apiPost(endpoint, data),
            put: async (endpoint, data) => {
                const response = await fetch(getApiBase() + endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                return response.json();
            },
            delete: async (endpoint) => {
                const response = await fetch(getApiBase() + endpoint, { method: 'DELETE' });
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                return response.json();
            }
        };

        // Initialize ActionManager
        const actionManager = new ActionManager(apiClient);

        // DOM elements
        const deviceSelect = document.getElementById('deviceSelect');
        const streamModeSelect = document.getElementById('streamMode');
        const streamQualitySelect = document.getElementById('streamQuality');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const refreshDevicesBtn = document.getElementById('refreshDevicesBtn');
        const showOverlays = document.getElementById('showOverlays');
        const showLabels = document.getElementById('showLabels');
        const canvas = document.getElementById('streamCanvas');
        const noStream = document.getElementById('noStream');
        const lastTapDiv = document.getElementById('lastTap');

        // New metric elements
        const bandwidthValue = document.getElementById('bandwidthValue');
        const streamModeValue = document.getElementById('streamModeValue');

        // Element overlay controls
        const refreshElementsBtn = document.getElementById('refreshElementsBtn');
        const elementStatus = document.getElementById('elementStatus');
        const filterClickable = document.getElementById('filterClickable');
        const filterWithText = document.getElementById('filterWithText');
        const filterLargeElements = document.getElementById('filterLargeElements');

        // Selected element controls
        const selectedElementCard = document.getElementById('selectedElementCard');
        const createActionBtn = document.getElementById('createActionBtn');
        const clearSelectionBtn = document.getElementById('clearSelectionBtn');

        // State for element selection
        let allElements = [];
        let filteredElements = [];
        let selectedElement = null;
        let autoRefreshTimer = null;

        // Auto-refresh controls
        const autoRefreshElements = document.getElementById('autoRefreshElements');
        const autoRefreshInterval = document.getElementById('autoRefreshInterval');

        // Metric elements
        const statusValue = document.getElementById('statusValue');
        const fpsValue = document.getElementById('fpsValue');
        const latencyValue = document.getElementById('latencyValue');
        const captureValue = document.getElementById('captureValue');
        const frameValue = document.getElementById('frameValue');
        const elementsValue = document.getElementById('elementsValue');

        // Initialize LiveStream
        const liveStream = new LiveStream(canvas);

        // Callbacks
        liveStream.onConnect = () => {
            statusValue.textContent = 'Connected';
            statusValue.className = 'metric-value status-connected';
            noStream.style.display = 'none';
            startBtn.disabled = true;
            stopBtn.disabled = false;
        };

        liveStream.onDisconnect = () => {
            statusValue.textContent = 'Disconnected';
            statusValue.className = 'metric-value status-disconnected';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            streamModeValue.textContent = '--';
            bandwidthValue.textContent = '0 KB/s';
            stopAutoRefresh();
            autoRefreshElements.checked = false;
        };

        liveStream.onError = (error) => {
            statusValue.textContent = 'Error';
            statusValue.className = 'metric-value status-error';
            console.error('Stream error:', error);
            alert('Stream error: ' + error.message);
        };

        liveStream.onMetricsUpdate = (metrics) => {
            fpsValue.textContent = metrics.fps;
            latencyValue.textContent = metrics.latency + ' ms';
            captureValue.textContent = metrics.captureTime + ' ms';
            frameValue.textContent = metrics.frameCount;
            bandwidthValue.textContent = metrics.bandwidth + ' KB/s';
        };

        liveStream.onFrame = (data) => {
            if (data.elements && data.elements.length > 0) {
                elementsValue.textContent = data.elements.length;
            }
        };

        // Connection state change handler (for auto-reconnect indicator)
        const connectionStatus = document.getElementById('connectionStatus');
        const statusText = connectionStatus.querySelector('.status-text');

        liveStream.onConnectionStateChange = (state, attempts) => {
            // Update indicator classes
            connectionStatus.className = 'connection-status ' + state;

            // Update text
            switch (state) {
                case 'disconnected':
                    statusText.textContent = 'Disconnected';
                    break;
                case 'connecting':
                    statusText.textContent = 'Connecting...';
                    break;
                case 'connected':
                    statusText.textContent = 'Connected';
                    break;
                case 'reconnecting':
                    statusText.textContent = `Reconnecting (${attempts + 1})`;
                    break;
            }

            console.log(`[UI] Connection state: ${state}` + (attempts > 0 ? ` (attempt ${attempts})` : ''));
        };

        // Load devices
        async function loadDevices() {
            try {
                const data = await apiGet('/adb/devices');
                deviceSelect.innerHTML = '<option value="">-- Select Device --</option>';

                data.devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = `${device.id} (${device.model || 'Unknown'})`;
                    deviceSelect.appendChild(option);
                });

                console.log(`Loaded ${data.devices.length} devices`);
            } catch (error) {
                console.error('Failed to load devices:', error);
                alert('Failed to load devices: ' + error.message);
            }
        }

        // Event handlers
        startBtn.addEventListener('click', async () => {
            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }
            const mode = streamModeSelect.value;
            const quality = streamQualitySelect.value;
            const qualityLabel = streamQualitySelect.options[streamQualitySelect.selectedIndex].text;

            if (mode === 'scrcpy') {
                // Handle scrcpy streaming
                streamModeValue.textContent = 'scrcpy - High FPS';

                // Get the canvas element
                const canvas = document.getElementById('streamCanvas');
                if (!canvas) {
                    alert('Stream canvas not found');
                    return;
                }

                // Try to dynamically import scrcpy client
                try {
                    const { default: ScrcpyClient } = await import('./js/modules/scrcpy-client.js?v=0.0.5');
                    const scrcpyClient = new ScrcpyClient(canvas);

                    // Set up callbacks
                    scrcpyClient.onFrame = () => {
                        fpsValue.textContent = scrcpyClient.fps || '--';
                    };
                    scrcpyClient.onError = (error) => {
                        console.error('[scrcpy] Error:', error);
                        alert('scrcpy error: ' + error.message);
                    };

                    scrcpyClient.start(deviceId, 'ws://localhost:8000');

                    // Store reference for stop button
                    window._scrcpyClient = scrcpyClient;

                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } catch (e) {
                    console.error('[scrcpy] Failed to start:', e);
                    alert('Failed to start scrcpy stream. Make sure ws-scrcpy is running on port 8000.\n\nError: ' + e.message);
                }
            } else {
                // Regular MJPEG or WebSocket mode
                streamModeValue.textContent = `${mode === 'mjpeg' ? 'MJPEG' : 'Base64'} - ${qualityLabel}`;
                liveStream.start(deviceId, mode, quality);
            }
        });

        stopBtn.addEventListener('click', () => {
            // Stop scrcpy if active
            if (window._scrcpyClient) {
                window._scrcpyClient.stop();
                window._scrcpyClient = null;
            }
            liveStream.stop();
        });

        refreshDevicesBtn.addEventListener('click', loadDevices);

        showOverlays.addEventListener('change', (e) => {
            liveStream.setOverlaysVisible(e.target.checked);
        });

        showLabels.addEventListener('change', (e) => {
            liveStream.setTextLabelsVisible(e.target.checked);
        });

        // Element filtering and display functions
        function applyFilters() {
            if (allElements.length === 0) {
                elementStatus.textContent = 'Click "Refresh Elements" first';
                return;
            }

            filteredElements = allElements.filter(el => {
                // Filter by clickable
                if (filterClickable.checked && !el.clickable) return false;

                // Filter by text
                if (filterWithText.checked && (!el.text || !el.text.trim())) return false;

                // Filter small elements
                if (filterLargeElements.checked && el.bounds) {
                    if (el.bounds.width < 20 || el.bounds.height < 20) return false;
                }

                return true;
            });

            // Update liveStream elements
            liveStream.elements = filteredElements;
            elementsValue.textContent = filteredElements.length;

            // Update status
            elementStatus.textContent = `${allElements.length} elements (${filteredElements.length} shown)`;
            console.log(`[Filters] ${allElements.length} total -> ${filteredElements.length} shown`);

            // Re-render overlays on current frame
            if (liveStream.currentImage) {
                liveStream._renderFrame(liveStream.currentImage, filteredElements);
            }
        }

        async function refreshElements() {
            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            elementStatus.textContent = 'Loading...';
            refreshElementsBtn.disabled = true;

            try {
                const data = await apiPost('/adb/screenshot', { device_id: deviceId });
                if (data.elements && data.elements.length > 0) {
                    allElements = data.elements;
                    applyFilters();
                    elementStatus.textContent = `${allElements.length} elements (${filteredElements.length} shown)`;
                } else {
                    allElements = [];
                    filteredElements = [];
                    elementStatus.textContent = 'No elements found';
                }
            } catch (error) {
                console.error('Failed to refresh elements:', error);
                elementStatus.textContent = 'Error loading elements';
            } finally {
                refreshElementsBtn.disabled = false;
            }
        }

        function showSelectedElement(element) {
            selectedElement = element;
            selectedElementCard.style.display = 'block';

            document.getElementById('elClass').textContent = element.class || '-';
            document.getElementById('elText').textContent = element.text || '-';
            document.getElementById('elResourceId').textContent = element.resource_id || '-';
            document.getElementById('elContentDesc').textContent = element.content_desc || '-';
            document.getElementById('elBounds').textContent = element.bounds
                ? `(${element.bounds.x}, ${element.bounds.y}) ${element.bounds.width}x${element.bounds.height}`
                : '-';
            document.getElementById('elClickable').textContent = element.clickable ? 'Yes' : 'No';

            // Highlight the selected element on canvas
            if (liveStream.currentImage) {
                liveStream._renderFrame(liveStream.currentImage, filteredElements);
                // Draw highlight around selected
                const ctx = liveStream.ctx;
                const b = element.bounds;
                if (b) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(b.x, b.y, b.width, b.height);
                }
            }
        }

        function clearSelection() {
            selectedElement = null;
            selectedElementCard.style.display = 'none';
            // Re-render without highlight
            if (liveStream.currentImage) {
                liveStream._renderFrame(liveStream.currentImage, filteredElements);
            }
        }

        // Dialog elements
        const createActionDialog = document.getElementById('createActionDialog');
        const actionNameInput = document.getElementById('actionName');
        const actionDescInput = document.getElementById('actionDescription');
        const actionTypeSelect = document.getElementById('actionType');
        const actionXInput = document.getElementById('actionX');
        const actionYInput = document.getElementById('actionY');
        const actionTagsInput = document.getElementById('actionTags');
        const actionElementInfo = document.getElementById('actionElementInfo');
        const saveActionBtn = document.getElementById('saveActionBtn');
        const cancelActionBtn = document.getElementById('cancelActionBtn');

        function showCreateActionDialog() {
            if (!selectedElement) {
                alert('No element selected');
                return;
            }

            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            // Get center of element for tap action
            const b = selectedElement.bounds;
            const centerX = Math.round(b.x + b.width / 2);
            const centerY = Math.round(b.y + b.height / 2);

            // Generate default action name
            const defaultName = selectedElement.text?.trim()
                || selectedElement.content_desc?.trim()
                || selectedElement.resource_id?.split('/').pop()
                || selectedElement.class?.split('.').pop()
                || 'Unnamed Action';

            // Populate dialog
            actionNameInput.value = defaultName;
            actionDescInput.value = `Tap on ${selectedElement.class || 'element'}`;
            actionTypeSelect.value = 'tap';
            actionXInput.value = centerX;
            actionYInput.value = centerY;
            actionTagsInput.value = '';
            actionElementInfo.innerHTML = `
                <strong>Element:</strong> ${selectedElement.class?.split('.').pop() || 'Unknown'}<br>
                <strong>Resource ID:</strong> ${selectedElement.resource_id || 'N/A'}<br>
                <strong>Text:</strong> ${selectedElement.text || 'N/A'}
            `;

            // Show dialog
            createActionDialog.style.display = 'flex';
            actionNameInput.focus();
        }

        function hideCreateActionDialog() {
            createActionDialog.style.display = 'none';
        }

        async function saveAction() {
            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            const name = actionNameInput.value.trim();
            if (!name) {
                alert('Please enter an action name');
                return;
            }

            const x = parseInt(actionXInput.value);
            const y = parseInt(actionYInput.value);
            if (isNaN(x) || isNaN(y)) {
                alert('Invalid coordinates');
                return;
            }

            // Set device for ActionManager
            actionManager.setDevice(deviceId);

            // Parse tags
            const tags = actionTagsInput.value.split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);

            // Build action config
            const actionConfig = {
                name: name,
                description: actionDescInput.value.trim(),
                action_type: actionTypeSelect.value,
                x: x,
                y: y,
                enabled: true
            };

            try {
                saveActionBtn.disabled = true;
                saveActionBtn.textContent = 'Saving...';

                const result = await actionManager.createAction(actionConfig, tags);

                console.log('Action created:', result);
                alert(`Action created: ${name}`);
                hideCreateActionDialog();
                clearSelection();
            } catch (error) {
                console.error('Failed to create action:', error);
                alert('Failed to create action: ' + error.message);
            } finally {
                saveActionBtn.disabled = false;
                saveActionBtn.textContent = 'Save Action';
            }
        }

        // Dialog event handlers
        saveActionBtn.addEventListener('click', saveAction);
        cancelActionBtn.addEventListener('click', hideCreateActionDialog);
        createActionDialog.addEventListener('click', (e) => {
            if (e.target === createActionDialog) hideCreateActionDialog();
        });

        // Auto-refresh functions
        function startAutoRefresh() {
            const interval = parseInt(autoRefreshInterval.value);
            console.log(`[AutoRefresh] Starting with ${interval}ms interval`);
            stopAutoRefresh();
            autoRefreshTimer = setInterval(async () => {
                if (liveStream.isActive()) {
                    console.log('[AutoRefresh] Refreshing elements...');
                    await refreshElements();
                }
            }, interval);
        }

        function stopAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
                console.log('[AutoRefresh] Stopped');
            }
        }

        // Element overlay event handlers
        refreshElementsBtn.addEventListener('click', refreshElements);
        filterClickable.addEventListener('change', applyFilters);
        filterWithText.addEventListener('change', applyFilters);
        filterLargeElements.addEventListener('change', applyFilters);
        createActionBtn.addEventListener('click', showCreateActionDialog);
        clearSelectionBtn.addEventListener('click', clearSelection);

        // Auto-refresh event handlers
        autoRefreshElements.addEventListener('change', (e) => {
            if (e.target.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        });

        autoRefreshInterval.addEventListener('change', () => {
            if (autoRefreshElements.checked) {
                startAutoRefresh(); // Restart with new interval
            }
        });

        // Canvas drag/swipe and tap handler
        let dragStart = null;
        let isDragging = false;
        const MIN_SWIPE_DISTANCE = 30; // Minimum pixels to count as swipe

        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const container = document.getElementById('canvasContainer').getBoundingClientRect();

            // Canvas is centered in container - calculate the actual canvas position
            // The canvas maintains aspect ratio, so we need to find where it actually is
            const canvasAspect = canvas.width / canvas.height;
            const containerAspect = container.width / container.height;

            let actualWidth, actualHeight, offsetX, offsetY;

            if (canvasAspect > containerAspect) {
                // Canvas is wider - limited by container width
                actualWidth = container.width;
                actualHeight = container.width / canvasAspect;
                offsetX = 0;
                offsetY = (container.height - actualHeight) / 2;
            } else {
                // Canvas is taller - limited by container height (this is our case)
                actualHeight = container.height;
                actualWidth = container.height * canvasAspect;
                offsetX = (container.width - actualWidth) / 2;
                offsetY = 0;
            }

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Account for zoom and pan
            // When zoomed, the canvas is scaled and translated
            const zoomedWidth = actualWidth * zoomScale;
            const zoomedHeight = actualHeight * zoomScale;

            // Center of zoomed canvas
            const zoomOffsetX = (container.width - zoomedWidth) / 2 + (panX * zoomScale);
            const zoomOffsetY = (container.height - zoomedHeight) / 2 + (panY * zoomScale);

            // Calculate position relative to zoomed canvas
            const relX = (clientX - container.left - zoomOffsetX) / zoomScale;
            const relY = (clientY - container.top - zoomOffsetY) / zoomScale;

            // Scale to canvas coordinates
            const scaleX = canvas.width / actualWidth;
            const scaleY = canvas.height / actualHeight;

            const coords = {
                x: Math.round(relX * scaleX),
                y: Math.round(relY * scaleY)
            };

            // Clamp to valid canvas coordinates
            coords.x = Math.max(0, Math.min(canvas.width - 1, coords.x));
            coords.y = Math.max(0, Math.min(canvas.height - 1, coords.y));

            if (zoomScale !== 1) {
                console.log(`[Coords] Zoom: ${Math.round(zoomScale * 100)}%, Pan: (${Math.round(panX)}, ${Math.round(panY)}), Click: (${coords.x}, ${coords.y})`);
            }
            return coords;
        }

        function onDragStart(e) {
            if (!liveStream.isActive()) return;
            e.preventDefault();
            dragStart = getCanvasCoords(e);
            isDragging = true;
            canvas.style.cursor = 'grabbing';
        }

        async function onDragEnd(e) {
            if (!isDragging || !dragStart) return;

            const endCoords = e.changedTouches
                ? { x: Math.round((e.changedTouches[0].clientX - canvas.getBoundingClientRect().left) * (canvas.width / canvas.getBoundingClientRect().width)),
                    y: Math.round((e.changedTouches[0].clientY - canvas.getBoundingClientRect().top) * (canvas.height / canvas.getBoundingClientRect().height)) }
                : getCanvasCoords(e);

            const dx = endCoords.x - dragStart.x;
            const dy = endCoords.y - dragStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            isDragging = false;
            canvas.style.cursor = 'crosshair';

            const deviceId = deviceSelect.value;
            if (!deviceId) return;

            if (distance < MIN_SWIPE_DISTANCE) {
                // It's a tap
                console.log(`Tap at (${dragStart.x}, ${dragStart.y})`);
                lastTapDiv.textContent = `Last tap: (${dragStart.x}, ${dragStart.y})`;

                // Show tap ripple effect at click position
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();
                const canvasAspect = canvas.width / canvas.height;
                const containerAspect = containerRect.width / containerRect.height;

                let actualWidth, actualHeight, offsetX, offsetY;
                if (canvasAspect > containerAspect) {
                    actualWidth = containerRect.width;
                    actualHeight = containerRect.width / canvasAspect;
                    offsetX = 0;
                    offsetY = (containerRect.height - actualHeight) / 2;
                } else {
                    actualHeight = containerRect.height;
                    actualWidth = containerRect.height * canvasAspect;
                    offsetX = (containerRect.width - actualWidth) / 2;
                    offsetY = 0;
                }

                const displayX = (dragStart.x / canvas.width) * actualWidth + offsetX;
                const displayY = (dragStart.y / canvas.height) * actualHeight + offsetY;

                // Show tap indicator with ripple animation
                showTapRipple(container, displayX, displayY);
                console.log(`[TapRipple] Display pos: (${Math.round(displayX)}, ${Math.round(displayY)}), Canvas pos: (${dragStart.x}, ${dragStart.y})`);

                // Check for element at tap position (use filteredElements directly)
                console.log(`[Tap] Checking ${filteredElements.length} elements for hit at (${dragStart.x}, ${dragStart.y})`);
                let foundElement = null;
                for (let i = filteredElements.length - 1; i >= 0; i--) {
                    const el = filteredElements[i];
                    if (!el.bounds) continue;
                    const b = el.bounds;
                    if (dragStart.x >= b.x && dragStart.x <= b.x + b.width &&
                        dragStart.y >= b.y && dragStart.y <= b.y + b.height) {
                        foundElement = el;
                        break;
                    }
                }

                if (foundElement) {
                    console.log(`[Tap] Found element:`, foundElement);
                    showSelectedElement(foundElement);
                    lastTapDiv.textContent = `Last tap: (${dragStart.x}, ${dragStart.y}) - ${foundElement.text || foundElement.class || 'element'}`;
                } else {
                    console.log(`[Tap] No element found at position`);
                }

                try {
                    console.log(`[Input] Sending tap at (${dragStart.x}, ${dragStart.y})`);
                    const tapResult = await apiPost('/adb/tap', {
                        device_id: deviceId,
                        x: dragStart.x,
                        y: dragStart.y
                    });
                    console.log(`[ADB] Tap result:`, tapResult);

                    // Record the tap if recording
                    recordAction('tap', { x: dragStart.x, y: dragStart.y });

                    // Auto-refresh elements after tap
                    refreshAfterAction(500);
                } catch (error) {
                    console.error('Tap failed:', error);
                }
            } else {
                // It's a swipe
                console.log(`Swipe from (${dragStart.x},${dragStart.y}) to (${endCoords.x},${endCoords.y})`);
                lastTapDiv.textContent = `Swipe: (${dragStart.x},${dragStart.y}) ‚Üí (${endCoords.x},${endCoords.y})`;

                // Show swipe path visualization
                const container = document.getElementById('canvasContainer');
                showSwipePath(container, dragStart.x, dragStart.y, endCoords.x, endCoords.y);

                try {
                    await apiPost('/adb/swipe', {
                        device_id: deviceId,
                        x1: dragStart.x,
                        y1: dragStart.y,
                        x2: endCoords.x,
                        y2: endCoords.y,
                        duration: 300
                    });

                    // Record the swipe if recording
                    recordAction('swipe', { x1: dragStart.x, y1: dragStart.y, x2: endCoords.x, y2: endCoords.y });

                    // Auto-refresh elements after swipe
                    refreshAfterAction(500);
                } catch (error) {
                    console.error('Swipe failed:', error);
                }
            }
            dragStart = null;
        }

        // Mouse events
        canvas.addEventListener('mousedown', onDragStart);
        canvas.addEventListener('mouseup', onDragEnd);
        canvas.addEventListener('mouseleave', () => {
            if (isDragging) {
                isDragging = false;
                dragStart = null;
                canvas.style.cursor = 'crosshair';
            }
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', onDragStart, { passive: false });
        canvas.addEventListener('touchend', onDragEnd);

        // Navigation controls
        const lastActionDiv = document.getElementById('lastAction');

        // Auto-refresh elements after actions with a delay
        async function refreshAfterAction(delayMs = 500) {
            setTimeout(async () => {
                try {
                    await refreshElements();
                } catch (e) {
                    console.warn('[AutoRefresh] Failed to refresh after action:', e);
                }
            }, delayMs);
        }

        async function sendKeyEvent(keycode, actionName) {
            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }
            try {
                await apiPost('/adb/keyevent', {
                    device_id: deviceId,
                    keycode: keycode
                });
                lastActionDiv.textContent = `Last action: ${actionName}`;
                console.log(`Key event: ${actionName} (keycode ${keycode})`);
                // Auto-refresh elements after screen change
                refreshAfterAction(600);
            } catch (error) {
                console.error(`${actionName} failed:`, error);
                lastActionDiv.textContent = `Last action: ${actionName} FAILED`;
            }
        }

        async function sendSwipe(direction) {
            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            // Get canvas dimensions for swipe calculations
            const w = canvas.width || 1080;
            const h = canvas.height || 1920;
            const cx = Math.round(w / 2);
            const cy = Math.round(h / 2);
            const swipeLen = Math.round(Math.min(w, h) * 0.4); // 40% of screen

            let x1, y1, x2, y2;
            switch (direction) {
                case 'up':
                    x1 = cx; y1 = cy + swipeLen; x2 = cx; y2 = cy - swipeLen;
                    break;
                case 'down':
                    x1 = cx; y1 = cy - swipeLen; x2 = cx; y2 = cy + swipeLen;
                    break;
                case 'left':
                    x1 = cx + swipeLen; y1 = cy; x2 = cx - swipeLen; y2 = cy;
                    break;
                case 'right':
                    x1 = cx - swipeLen; y1 = cy; x2 = cx + swipeLen; y2 = cy;
                    break;
            }

            try {
                await apiPost('/adb/swipe', {
                    device_id: deviceId,
                    x1: x1, y1: y1,
                    x2: x2, y2: y2,
                    duration: 300
                });
                lastActionDiv.textContent = `Last action: Swipe ${direction}`;
                console.log(`Swipe ${direction}: (${x1},${y1}) -> (${x2},${y2})`);
                // Auto-refresh elements after swipe
                refreshAfterAction(500);
            } catch (error) {
                console.error(`Swipe ${direction} failed:`, error);
                lastActionDiv.textContent = `Last action: Swipe ${direction} FAILED`;
            }
        }

        // Button event listeners
        document.getElementById('btnBack').addEventListener('click', () => sendKeyEvent(4, 'Back'));
        document.getElementById('btnHome').addEventListener('click', () => sendKeyEvent(3, 'Home'));
        document.getElementById('btnRecent').addEventListener('click', () => sendKeyEvent(187, 'Recent Apps'));
        document.getElementById('btnSwipeUp').addEventListener('click', () => sendSwipe('up'));
        document.getElementById('btnSwipeDown').addEventListener('click', () => sendSwipe('down'));
        document.getElementById('btnSwipeLeft').addEventListener('click', () => sendSwipe('left'));
        document.getElementById('btnSwipeRight').addEventListener('click', () => sendSwipe('right'));

        // ========================================
        // Element Hover Preview
        // ========================================

        const hoverTooltip = document.getElementById('hoverTooltip');
        let hoveredElement = null;
        let lastHoverCoords = { x: 0, y: 0 };

        /**
         * Handle mouse move for element hover preview
         */
        function handleCanvasHover(e) {
            if (!liveStream.isActive() || filteredElements.length === 0) {
                hideHoverTooltip();
                return;
            }

            const coords = getCanvasCoords(e);
            lastHoverCoords = coords;

            // Find ALL elements at hover position
            let elementsAtPoint = [];
            for (let i = filteredElements.length - 1; i >= 0; i--) {
                const el = filteredElements[i];
                if (!el.bounds) continue;
                const b = el.bounds;
                if (coords.x >= b.x && coords.x <= b.x + b.width &&
                    coords.y >= b.y && coords.y <= b.y + b.height) {
                    elementsAtPoint.push(el);
                }
            }

            // Prioritize: clickable elements first, then smallest area
            let foundElement = null;
            if (elementsAtPoint.length > 0) {
                // Separate clickable and non-clickable
                const clickable = elementsAtPoint.filter(el => el.clickable);
                const candidates = clickable.length > 0 ? clickable : elementsAtPoint;

                // Pick smallest element (most specific)
                foundElement = candidates.reduce((smallest, el) => {
                    const area = el.bounds.width * el.bounds.height;
                    const smallestArea = smallest.bounds.width * smallest.bounds.height;
                    return area < smallestArea ? el : smallest;
                });
            }

            if (foundElement && foundElement !== hoveredElement) {
                hoveredElement = foundElement;
                showHoverTooltip(e, foundElement);
                highlightHoveredElement(foundElement);
            } else if (!foundElement && hoveredElement) {
                hoveredElement = null;
                hideHoverTooltip();
                // Re-render without hover highlight
                if (liveStream.currentImage) {
                    liveStream._renderFrame(liveStream.currentImage, filteredElements);
                }
            } else if (foundElement) {
                // Update tooltip position
                updateTooltipPosition(e);
            }
        }

        /**
         * Show hover tooltip with element info
         */
        function showHoverTooltip(e, element) {
            const header = hoverTooltip.querySelector('.tooltip-header');
            const body = hoverTooltip.querySelector('.tooltip-body');

            // Header: element text or class name
            const displayName = element.text?.trim() ||
                               element.content_desc?.trim() ||
                               element.class?.split('.').pop() ||
                               'Element';
            header.textContent = displayName;

            // Body: element details
            const clickableBadge = element.clickable
                ? '<span class="clickable-badge">Clickable</span>'
                : '<span class="not-clickable-badge">Not Clickable</span>';

            let bodyHtml = `<div class="tooltip-row"><span class="tooltip-label">Class:</span><span class="tooltip-value">${element.class?.split('.').pop() || '-'}</span></div>`;

            if (element.resource_id) {
                const resId = element.resource_id.split('/').pop() || element.resource_id;
                bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">ID:</span><span class="tooltip-value">${resId}</span></div>`;
            }

            if (element.bounds) {
                bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">Size:</span><span class="tooltip-value">${element.bounds.width}x${element.bounds.height}</span></div>`;
            }

            bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">Status:</span><span class="tooltip-value">${clickableBadge}</span></div>`;

            body.innerHTML = bodyHtml;

            updateTooltipPosition(e);
            hoverTooltip.style.display = 'block';
        }

        /**
         * Update tooltip position near cursor
         */
        function updateTooltipPosition(e) {
            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();

            // Position tooltip near cursor but within container
            let x = e.clientX - containerRect.left + 15;
            let y = e.clientY - containerRect.top + 15;

            // Keep tooltip within container bounds
            const tooltipRect = hoverTooltip.getBoundingClientRect();
            if (x + tooltipRect.width > containerRect.width - 10) {
                x = e.clientX - containerRect.left - tooltipRect.width - 15;
            }
            if (y + tooltipRect.height > containerRect.height - 10) {
                y = e.clientY - containerRect.top - tooltipRect.height - 15;
            }

            hoverTooltip.style.left = Math.max(5, x) + 'px';
            hoverTooltip.style.top = Math.max(5, y) + 'px';
        }

        /**
         * Hide hover tooltip
         */
        function hideHoverTooltip() {
            hoverTooltip.style.display = 'none';
        }

        /**
         * Highlight hovered element on canvas
         */
        function highlightHoveredElement(element) {
            if (!liveStream.currentImage) return;

            // Re-render frame first
            liveStream._renderFrame(liveStream.currentImage, filteredElements);

            // Draw hover highlight
            const ctx = liveStream.ctx;
            const b = element.bounds;
            if (b) {
                // Cyan dashed border for hover
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(b.x, b.y, b.width, b.height);
                ctx.setLineDash([]); // Reset

                // Semi-transparent fill
                ctx.fillStyle = element.clickable
                    ? 'rgba(0, 255, 255, 0.15)'
                    : 'rgba(255, 255, 0, 0.1)';
                ctx.fillRect(b.x, b.y, b.width, b.height);
            }
        }

        // Add hover event listener
        canvas.addEventListener('mousemove', handleCanvasHover);
        canvas.addEventListener('mouseleave', () => {
            hoveredElement = null;
            hideHoverTooltip();
            if (liveStream.currentImage && liveStream.isActive()) {
                liveStream._renderFrame(liveStream.currentImage, filteredElements);
            }
        });

        // ========================================
        // Gesture Recording
        // ========================================

        const recordBtn = document.getElementById('recordBtn');
        const clearRecordingBtn = document.getElementById('clearRecordingBtn');
        const saveRecordingBtn = document.getElementById('saveRecordingBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingText = document.getElementById('recordingText');
        const recordedActionsDiv = document.getElementById('recordedActions');

        let isRecording = false;
        let recordedActions = [];

        /**
         * Toggle recording state
         */
        function toggleRecording() {
            isRecording = !isRecording;

            if (isRecording) {
                recordBtn.textContent = 'Stop Recording';
                recordBtn.classList.add('recording');
                recordingIndicator.classList.add('active');
                recordingText.textContent = 'Recording... Tap or swipe on the device';
                console.log('[Recording] Started');
            } else {
                recordBtn.textContent = 'Start Recording';
                recordBtn.classList.remove('recording');
                recordingIndicator.classList.remove('active');
                recordingText.textContent = recordedActions.length > 0
                    ? `Recorded ${recordedActions.length} action(s)`
                    : 'Not recording';
                console.log('[Recording] Stopped');
            }
        }

        /**
         * Record an action (tap or swipe)
         */
        function recordAction(type, data) {
            if (!isRecording) return;

            const action = {
                type: type,
                timestamp: Date.now(),
                ...data
            };

            recordedActions.push(action);
            updateRecordedActionsUI();

            clearRecordingBtn.disabled = false;
            saveRecordingBtn.disabled = false;

            console.log(`[Recording] Recorded ${type}:`, data);
        }

        /**
         * Update the recorded actions list UI
         */
        function updateRecordedActionsUI() {
            if (recordedActions.length === 0) {
                recordedActionsDiv.innerHTML = '<p class="empty-message">No actions recorded. Click "Start Recording" and interact with the device.</p>';
                return;
            }

            let html = '';
            recordedActions.forEach((action, index) => {
                const typeClass = action.type === 'tap' ? 'tap' : 'swipe';
                let coordsText = '';

                if (action.type === 'tap') {
                    coordsText = `(${action.x}, ${action.y})`;
                } else if (action.type === 'swipe') {
                    coordsText = `(${action.x1}, ${action.y1}) ‚Üí (${action.x2}, ${action.y2})`;
                }

                html += `
                    <div class="recorded-action-item" data-index="${index}">
                        <span class="action-number">${index + 1}</span>
                        <span class="action-type ${typeClass}">${action.type.toUpperCase()}</span>
                        <span class="action-coords">${coordsText}</span>
                        <button class="action-delete" onclick="deleteRecordedAction(${index})" title="Delete">√ó</button>
                    </div>
                `;
            });

            recordedActionsDiv.innerHTML = html;
        }

        /**
         * Delete a recorded action
         */
        window.deleteRecordedAction = function(index) {
            recordedActions.splice(index, 1);
            updateRecordedActionsUI();

            if (recordedActions.length === 0) {
                clearRecordingBtn.disabled = true;
                saveRecordingBtn.disabled = true;
                recordingText.textContent = isRecording ? 'Recording...' : 'Not recording';
            }
        };

        /**
         * Clear all recorded actions
         */
        function clearRecording() {
            recordedActions = [];
            updateRecordedActionsUI();
            clearRecordingBtn.disabled = true;
            saveRecordingBtn.disabled = true;
            recordingText.textContent = isRecording ? 'Recording...' : 'Not recording';
            console.log('[Recording] Cleared');
        }

        /**
         * Save recording as a Flow
         */
        async function saveRecordingAsFlow() {
            if (recordedActions.length === 0) {
                alert('No actions to save');
                return;
            }

            const deviceId = deviceSelect.value;
            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            const flowName = prompt('Enter a name for this flow:', `Recorded Flow ${new Date().toLocaleTimeString()}`);
            if (!flowName) return;

            // Convert recorded actions to flow steps
            const steps = recordedActions.map((action, index) => {
                if (action.type === 'tap') {
                    return {
                        step_number: index + 1,
                        action_type: 'tap',
                        x: action.x,
                        y: action.y,
                        delay_after: 500
                    };
                } else if (action.type === 'swipe') {
                    return {
                        step_number: index + 1,
                        action_type: 'swipe',
                        x: action.x1,
                        y: action.y1,
                        x2: action.x2,
                        y2: action.y2,
                        duration: 300,
                        delay_after: 500
                    };
                }
            });

            try {
                saveRecordingBtn.disabled = true;
                saveRecordingBtn.textContent = 'Saving...';

                const response = await apiPost('/flows', {
                    name: flowName,
                    description: `Recorded from Live Stream on ${new Date().toLocaleString()}`,
                    device_id: deviceId,
                    steps: steps,
                    enabled: true
                });

                console.log('[Recording] Flow saved:', response);
                alert(`Flow "${flowName}" saved with ${steps.length} steps!`);

                // Clear after save
                clearRecording();

            } catch (error) {
                console.error('[Recording] Failed to save flow:', error);
                alert('Failed to save flow: ' + error.message);
            } finally {
                saveRecordingBtn.disabled = recordedActions.length === 0;
                saveRecordingBtn.textContent = 'Save as Flow';
            }
        }

        // Recording button handlers
        recordBtn.addEventListener('click', toggleRecording);
        clearRecordingBtn.addEventListener('click', clearRecording);
        saveRecordingBtn.addEventListener('click', saveRecordingAsFlow);

        // ========================================
        // Touch Feedback Visualization Functions
        // ========================================

        /**
         * Show animated tap ripple at position
         */
        function showTapRipple(container, x, y) {
            // Create main tap indicator
            const tapIndicator = document.getElementById('tapIndicator');
            tapIndicator.style.left = x + 'px';
            tapIndicator.style.top = y + 'px';
            tapIndicator.style.display = 'block';
            // Reset animation by forcing reflow
            tapIndicator.style.animation = 'none';
            tapIndicator.offsetHeight;
            tapIndicator.style.animation = '';

            // Create expanding ripple ring
            const ring = document.createElement('div');
            ring.className = 'tap-ripple-ring';
            ring.style.left = x + 'px';
            ring.style.top = y + 'px';
            container.appendChild(ring);

            // Create second ring (delayed)
            setTimeout(() => {
                const ring2 = document.createElement('div');
                ring2.className = 'tap-ripple-ring';
                ring2.style.left = x + 'px';
                ring2.style.top = y + 'px';
                container.appendChild(ring2);
                setTimeout(() => ring2.remove(), 800);
            }, 150);

            // Cleanup
            setTimeout(() => {
                ring.remove();
                tapIndicator.style.display = 'none';
            }, 1500);
        }

        /**
         * Show animated swipe path from start to end
         */
        function showSwipePath(container, startX, startY, endX, endY) {
            const swipeContainer = document.getElementById('swipePathContainer');
            const containerRect = container.getBoundingClientRect();

            // Convert canvas coords to display coords
            const canvasAspect = canvas.width / canvas.height;
            const containerAspect = containerRect.width / containerRect.height;

            let actualWidth, actualHeight, offsetX, offsetY;
            if (canvasAspect > containerAspect) {
                actualWidth = containerRect.width;
                actualHeight = containerRect.width / canvasAspect;
                offsetX = 0;
                offsetY = (containerRect.height - actualHeight) / 2;
            } else {
                actualHeight = containerRect.height;
                actualWidth = containerRect.height * canvasAspect;
                offsetX = (containerRect.width - actualWidth) / 2;
                offsetY = 0;
            }

            const displayStartX = (startX / canvas.width) * actualWidth + offsetX;
            const displayStartY = (startY / canvas.height) * actualHeight + offsetY;
            const displayEndX = (endX / canvas.width) * actualWidth + offsetX;
            const displayEndY = (endY / canvas.height) * actualHeight + offsetY;

            // Calculate arrow direction
            const dx = displayEndX - displayStartX;
            const dy = displayEndY - displayStartY;
            const angle = Math.atan2(dy, dx);
            const arrowSize = 12;

            // Create SVG path with arrow
            swipeContainer.innerHTML = `
                <svg style="width: 100%; height: 100%; position: absolute; top: 0; left: 0; overflow: visible;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" class="swipe-arrow"/>
                        </marker>
                    </defs>
                    <line x1="${displayStartX}" y1="${displayStartY}"
                          x2="${displayEndX}" y2="${displayEndY}"
                          class="swipe-line" marker-end="url(#arrowhead)"/>
                </svg>
            `;

            // Add start dot
            const startDot = document.createElement('div');
            startDot.className = 'swipe-dot swipe-dot-start';
            startDot.style.left = displayStartX + 'px';
            startDot.style.top = displayStartY + 'px';
            swipeContainer.appendChild(startDot);

            // Add end dot
            const endDot = document.createElement('div');
            endDot.className = 'swipe-dot swipe-dot-end';
            endDot.style.left = displayEndX + 'px';
            endDot.style.top = displayEndY + 'px';
            swipeContainer.appendChild(endDot);

            swipeContainer.style.display = 'block';

            // Cleanup after animation
            setTimeout(() => {
                swipeContainer.style.display = 'none';
                swipeContainer.innerHTML = '';
            }, 1500);
        }

        // ========================================
        // Zoom/Pan State
        // ========================================

        let zoomScale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 5;
        const ZOOM_STEP = 0.25;

        const zoomLevelDisplay = document.getElementById('zoomLevel');

        function updateZoomDisplay() {
            zoomLevelDisplay.textContent = Math.round(zoomScale * 100) + '%';
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoomScale}) translate(${panX}px, ${panY}px)`;
            canvas.style.transformOrigin = 'center center';
            updateZoomDisplay();
        }

        function zoomIn(centerX, centerY) {
            if (zoomScale >= MAX_ZOOM) return;
            zoomScale = Math.min(MAX_ZOOM, zoomScale + ZOOM_STEP);
            applyZoom();
        }

        function zoomOut(centerX, centerY) {
            if (zoomScale <= MIN_ZOOM) return;
            zoomScale = Math.max(MIN_ZOOM, zoomScale - ZOOM_STEP);
            // Reset pan if zooming back to 1x or less
            if (zoomScale <= 1) {
                panX = 0;
                panY = 0;
            }
            applyZoom();
        }

        function resetZoom() {
            zoomScale = 1;
            panX = 0;
            panY = 0;
            applyZoom();
        }

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            if (!liveStream.isActive()) return;
            e.preventDefault();

            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }, { passive: false });

        // Pan when zoomed (middle mouse or when scale > 1)
        canvas.addEventListener('mousedown', (e) => {
            // Middle mouse button or zoomed in + right click
            if (e.button === 1 || (zoomScale > 1 && e.button === 2)) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX - panX;
                panStartY = e.clientY - panY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                panX = e.clientX - panStartX;
                panY = e.clientY - panStartY;
                applyZoom();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = zoomScale > 1 ? 'grab' : 'crosshair';
            }
        });

        // Prevent context menu when panning with right click
        canvas.addEventListener('contextmenu', (e) => {
            if (zoomScale > 1) {
                e.preventDefault();
            }
        });

        // Touch pinch zoom
        let touchStartDistance = 0;
        let touchStartScale = 1;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                touchStartScale = zoomScale;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = (distance / touchStartDistance) * touchStartScale;
                zoomScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, scale));
                applyZoom();
            }
        }, { passive: false });

        // ========================================
        // Quick Actions Bar
        // ========================================

        document.getElementById('qabRefresh').addEventListener('click', refreshElements);
        document.getElementById('qabBack').addEventListener('click', () => sendKeyEvent(4, 'Back'));
        document.getElementById('qabHome').addEventListener('click', () => sendKeyEvent(3, 'Home'));
        document.getElementById('qabRecent').addEventListener('click', () => sendKeyEvent(187, 'Recent Apps'));

        // Zoom controls
        document.getElementById('qabZoomIn').addEventListener('click', () => zoomIn());
        document.getElementById('qabZoomOut').addEventListener('click', () => zoomOut());
        document.getElementById('qabZoomReset').addEventListener('click', () => resetZoom());

        // Screenshot save
        document.getElementById('qabScreenshot').addEventListener('click', () => {
            if (!liveStream.currentImage) {
                alert('No frame available');
                return;
            }

            // Create a temporary canvas with just the screenshot (no overlays)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = liveStream.currentImage.width;
            tempCanvas.height = liveStream.currentImage.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(liveStream.currentImage, 0, 0);

            // Download as PNG
            const link = document.createElement('a');
            link.download = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();

            console.log('[Screenshot] Saved:', link.download);
        });

        // Fullscreen toggle
        let isFullscreen = false;
        document.getElementById('qabFullscreen').addEventListener('click', () => {
            const streamCard = document.querySelector('.stream-card');
            isFullscreen = !isFullscreen;

            if (isFullscreen) {
                streamCard.classList.add('fullscreen');
                document.getElementById('qabFullscreen').querySelector('.quick-icon').textContent = '‚õ∂';
            } else {
                streamCard.classList.remove('fullscreen');
                document.getElementById('qabFullscreen').querySelector('.quick-icon').textContent = '‚õ∂';
            }
        });

        // ESC to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                document.querySelector('.stream-card').classList.remove('fullscreen');
                isFullscreen = false;
            }
        });

        // ========================================
        // Split View - Element Tree
        // ========================================

        let isSplitView = false;
        const splitViewContainer = document.getElementById('splitViewContainer');
        const elementTreePanel = document.getElementById('elementTreePanel');
        const elementTreeContent = document.getElementById('elementTreeContent');
        const treeSearch = document.getElementById('treeSearch');
        let selectedTreeElement = null;

        // Toggle split view
        document.getElementById('qabSplitView').addEventListener('click', () => {
            isSplitView = !isSplitView;

            if (isSplitView) {
                splitViewContainer.classList.add('split-active');
                elementTreePanel.style.display = 'flex';
                renderElementTree();
            } else {
                splitViewContainer.classList.remove('split-active');
                elementTreePanel.style.display = 'none';
            }
        });

        // Render element tree
        function renderElementTree() {
            const searchTerm = treeSearch.value.toLowerCase();

            if (filteredElements.length === 0) {
                elementTreeContent.innerHTML = '<p class="tree-empty">Click "Refresh Elements" to load</p>';
                return;
            }

            // Filter by search
            let displayElements = filteredElements;
            if (searchTerm) {
                displayElements = filteredElements.filter(el =>
                    (el.text?.toLowerCase().includes(searchTerm)) ||
                    (el.resource_id?.toLowerCase().includes(searchTerm)) ||
                    (el.class?.toLowerCase().includes(searchTerm)) ||
                    (el.content_desc?.toLowerCase().includes(searchTerm))
                );
            }

            if (displayElements.length === 0) {
                elementTreeContent.innerHTML = '<p class="tree-empty">No elements match search</p>';
                return;
            }

            let html = '';
            displayElements.forEach((el, index) => {
                const displayText = el.text?.trim() || el.content_desc?.trim() || '';
                const className = el.class?.split('.').pop() || 'Unknown';
                const resId = el.resource_id?.split('/').pop() || '';
                const isClickable = el.clickable;
                const isSelected = selectedTreeElement === el;

                html += `
                    <div class="tree-item ${isClickable ? 'clickable' : 'not-clickable'} ${isSelected ? 'selected' : ''}"
                         data-index="${index}">
                        <div class="tree-item-header">
                            <span class="tree-item-class">${className}</span>
                            ${isClickable ? '<span class="tree-item-badge">Clickable</span>' : ''}
                        </div>
                        ${displayText ? `<div class="tree-item-text">"${displayText}"</div>` : ''}
                        ${resId ? `<div class="tree-item-id">${resId}</div>` : ''}
                        <div class="tree-item-actions">
                            <button class="tree-btn tree-btn-highlight" onclick="highlightTreeElement(${index})" title="Highlight on screen">üëÅ</button>
                            <button class="tree-btn tree-btn-press" onclick="pressTreeElement(${index})" title="Tap this element">Press</button>
                        </div>
                        <div class="tree-item-actions">
                            <button class="tree-btn tree-btn-action" onclick="createActionFromTree(${index})" title="Create action from element">+ Action</button>
                            <button class="tree-btn tree-btn-sensor" onclick="createSensorFromTree(${index})" title="Create sensor from element">+ Sensor</button>
                        </div>
                    </div>
                `;
            });

            elementTreeContent.innerHTML = html;
        }

        // Get elements based on current search filter
        function getDisplayedElements() {
            return treeSearch.value
                ? filteredElements.filter(el =>
                    (el.text?.toLowerCase().includes(treeSearch.value.toLowerCase())) ||
                    (el.resource_id?.toLowerCase().includes(treeSearch.value.toLowerCase())) ||
                    (el.class?.toLowerCase().includes(treeSearch.value.toLowerCase())) ||
                    (el.content_desc?.toLowerCase().includes(treeSearch.value.toLowerCase()))
                  )
                : filteredElements;
        }

        // Highlight element on canvas (temporary, just visual)
        window.highlightTreeElement = function(index) {
            const elements = getDisplayedElements();
            if (index < 0 || index >= elements.length) return;

            const element = elements[index];
            highlightHoveredElement(element);
            console.log('[Tree] Highlighted element:', element.class?.split('.').pop());
        };

        // Select element from tree (populates Selected Element card)
        window.selectTreeElement = function(index) {
            const elements = getDisplayedElements();
            if (index < 0 || index >= elements.length) return;

            const element = elements[index];
            selectedTreeElement = element;

            // Show in selected element card (enables Create Action)
            showSelectedElement(element);

            // Update tree UI to show selected state
            renderElementTree();

            // Scroll the selected element card into view
            selectedElementCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            console.log('[Tree] Selected element:', element);
        };

        // Create action from tree element
        window.createActionFromTree = function(index) {
            const elements = getDisplayedElements();
            if (index < 0 || index >= elements.length) return;

            const element = elements[index];

            // Select the element first (populates selectedElement)
            selectedElement = element;
            selectedTreeElement = element;

            // Open the create action dialog
            showCreateActionDialog();
        };

        // Create sensor from tree element
        window.createSensorFromTree = async function(index) {
            const elements = getDisplayedElements();
            if (index < 0 || index >= elements.length) return;

            const element = elements[index];
            const deviceId = deviceSelect.value;

            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            // Generate sensor name from element
            const sensorName = element.text?.trim() ||
                              element.content_desc?.trim() ||
                              element.resource_id?.split('/').pop() ||
                              element.class?.split('.').pop() ||
                              'Element Sensor';

            const name = prompt('Enter sensor name:', sensorName);
            if (!name) return;

            try {
                // Create sensor via API
                const sensorConfig = {
                    name: name,
                    device_id: deviceId,
                    element_selector: {}
                };

                // Build selector from element properties
                if (element.resource_id) {
                    sensorConfig.element_selector.resource_id = element.resource_id;
                } else if (element.text) {
                    sensorConfig.element_selector.text = element.text;
                } else if (element.content_desc) {
                    sensorConfig.element_selector.content_desc = element.content_desc;
                } else if (element.class) {
                    sensorConfig.element_selector.class_name = element.class;
                    if (element.bounds) {
                        // Use bounds as additional selector
                        sensorConfig.element_selector.bounds = element.bounds;
                    }
                }

                const result = await apiPost('/sensors', sensorConfig);
                console.log('[Tree] Sensor created:', result);
                alert(`Sensor "${name}" created!`);

            } catch (error) {
                console.error('[Tree] Failed to create sensor:', error);
                alert('Failed to create sensor: ' + error.message);
            }
        };

        // Press/tap element directly from tree
        window.pressTreeElement = async function(index) {
            const elements = getDisplayedElements();
            if (index < 0 || index >= elements.length) return;

            const element = elements[index];
            const deviceId = deviceSelect.value;

            if (!deviceId) {
                alert('Please select a device');
                return;
            }

            if (!element.bounds) {
                alert('Element has no bounds');
                return;
            }

            // Calculate center of element
            const b = element.bounds;
            const centerX = Math.round(b.x + b.width / 2);
            const centerY = Math.round(b.y + b.height / 2);

            // Highlight the element briefly
            highlightHoveredElement(element);

            try {
                console.log(`[Tree] Pressing element at (${centerX}, ${centerY})`);
                await apiPost('/adb/tap', {
                    device_id: deviceId,
                    x: centerX,
                    y: centerY
                });

                lastTapDiv.textContent = `Last tap: (${centerX}, ${centerY}) - ${element.text || element.class?.split('.').pop() || 'element'}`;

                // Record if recording
                recordAction('tap', { x: centerX, y: centerY });

                console.log('[Tree] Press successful');
            } catch (error) {
                console.error('[Tree] Press failed:', error);
                alert('Failed to tap element: ' + error.message);
            }
        };

        // Search input handler
        treeSearch.addEventListener('input', () => {
            renderElementTree();
        });

        // Update tree when elements are refreshed
        const originalApplyFilters = applyFilters;
        applyFilters = function() {
            originalApplyFilters();
            if (isSplitView) {
                renderElementTree();
            }
        };

        // Initialize
        loadDevices();
    </script>
</body>
</html>
