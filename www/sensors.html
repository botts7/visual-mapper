<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="0.0.16">
    <meta name="version" content="0.0.16" data-build="2026-01-01">
    <title>Sensors - Visual Mapper</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="css/styles.css?v=0.0.16">
</head>
<body>
    <nav>
        <ul>
            <!-- High priority - always visible -->
            <li class="nav-priority-high"><a href="main.html">Dashboard</a></li>
            <li class="nav-priority-high"><a href="devices.html">Devices</a></li>
            <li class="nav-priority-high"><a href="sensors.html" class="active">Sensors</a></li>

            <!-- Medium priority - hidden on mobile -->
            <li class="nav-priority-med"><a href="actions.html">Actions</a></li>
            <li class="nav-priority-med"><a href="flows.html">Flows</a></li>
            <li class="nav-priority-med"><a href="performance.html">Performance</a></li>
            <li class="nav-priority-med"><a href="diagnostic.html">Diagnostics</a></li>

            <!-- Low priority - hidden on tablet -->
            <li class="nav-priority-med"><a href="navigation-learn.html">Learn Nav</a></li>
            <li class="nav-priority-low"><a href="live-stream.html">Live Stream</a></li>
            <li class="nav-priority-low"><a href="dev.html">Dev Tools</a></li>

            <li class="version">v0.0.6</li>
            <li class="nav-logo"><img src="favicon.svg" alt="Visual Mapper"></li>
            <li id="themeToggleContainer"></li>
        </ul>
    </nav>

    <div class="container">
        <div class="card">
            <h1>Sensor Management</h1>
            <p>Manage Home Assistant sensors created from Android UI elements</p>
        </div>

        <div class="card">
            <h2>All Sensors</h2>

            <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                <select id="deviceFilter" style="flex: 1; min-width: 200px; max-width: 400px;">
                    <option value="">All Devices</option>
                </select>
                <input type="text" id="sensorSearch" placeholder="Search sensors..." style="flex: 1; min-width: 200px; max-width: 400px;">
                <button id="refreshBtn">Refresh</button>
            </div>

            <div id="sensorsContainer">
                <p class="status warning">Loading sensors...</p>
            </div>
        </div>
    </div>

    <script type="module">
        import APIClient from './js/modules/api-client.js?v=0.0.5';
        import ThemeToggle from './js/modules/theme-toggle.js?v=0.0.5';
        import MobileNav from './js/modules/mobile-nav.js?v=0.0.5';
        import SensorCreator from './js/modules/sensor-creator.js?v=0.0.9';
        import IconRenderer from './js/modules/icon-renderer.js?v=0.0.5';

        const apiClient = new APIClient();
        const themeToggle = new ThemeToggle();
        const mobileNav = new MobileNav();
        const sensorCreator = new SensorCreator(apiClient);
        const iconRenderer = new IconRenderer();

        // Apply theme immediately
        themeToggle.apply();

        // Initialize mobile navigation
        mobileNav.init();

        // Add theme toggle button to nav
        const themeToggleContainer = document.getElementById('themeToggleContainer');
        if (themeToggleContainer) {
            const toggleButton = themeToggle.createToggleButton((newTheme) => {
                console.log('Theme changed to:', newTheme);
            });
            themeToggleContainer.appendChild(toggleButton);
        }

        let allSensors = [];
        let deviceSensors = new Map(); // deviceId -> sensors[]
        let deviceInfo = new Map(); // deviceId -> device info (model, activity, etc.)
        let sensorsInFlows = new Set(); // sensor_ids that are referenced in flows
        let stableIdsWithFlows = new Set(); // stable_device_ids that have at least one flow
        let allFlows = []; // all flows across all devices

        // Extract app package from sensor (from target_app or element_resource_id)
        function extractAppFromSensor(sensor) {
            // First try target_app
            if (sensor.target_app) {
                return sensor.target_app;
            }
            // Fallback: extract from element_resource_id (format: "com.package.name:id/element_id")
            if (sensor.source?.element_resource_id) {
                const resourceId = sensor.source.element_resource_id;
                if (resourceId.includes(':')) {
                    return resourceId.split(':')[0];
                }
            }
            return null;
        }

        // Get friendly app name from package
        function getAppDisplayName(appPackage) {
            if (!appPackage) return null;
            const parts = appPackage.split('.');
            if (parts.length >= 2) {
                // Return last meaningful part, capitalized
                return parts[parts.length - 1].charAt(0).toUpperCase() + parts[parts.length - 1].slice(1);
            }
            return parts[parts.length - 1];
        }

        // Load all sensors and flows
        async function loadSensors() {
            try {
                // Get all devices
                const devicesResponse = await apiClient.get('/adb/devices');
                const devices = devicesResponse.devices || [];

                // Store device info for later use
                deviceInfo.clear();
                devices.forEach(dev => deviceInfo.set(dev.id, dev));

                // Load sensors per device AND all flows in parallel
                allSensors = [];
                deviceSensors.clear();
                sensorsInFlows.clear();
                stableIdsWithFlows.clear();
                allFlows = [];

                // Create parallel API call promises for sensors (per device) and ALL flows
                const sensorPromises = devices.map(device =>
                    apiClient.get(`/sensors/${device.id}`)
                        .then(response => ({type: 'sensors', device, data: response.sensors || []}))
                        .catch(error => {
                            console.error(`[Sensors] Failed to load sensors for ${device.id}:`, error);
                            return {type: 'sensors', device, data: []};
                        })
                );

                // Load ALL flows (not filtered by device) to match by stable_device_id
                // Note: API returns direct array, not {flows: [...]}
                const flowsPromise = apiClient.get('/flows')
                    .then(response => Array.isArray(response) ? response : (response.flows || []))
                    .catch(error => {
                        console.error('[Sensors] Failed to load flows:', error);
                        return [];
                    });

                // Wait for all API calls
                const [sensorResults, flowsData] = await Promise.all([
                    Promise.all(sensorPromises),
                    flowsPromise
                ]);

                // Process sensor results
                sensorResults.forEach(({type, device, data}) => {
                    if (data.length > 0) {
                        deviceSensors.set(device.id, data);
                        allSensors.push(...data);
                    }
                });

                // Process flows - extract sensor_ids AND stable_device_ids
                allFlows = flowsData;
                flowsData.forEach(flow => {
                    // Track stable_device_id for device-level flow detection
                    if (flow.stable_device_id) {
                        stableIdsWithFlows.add(flow.stable_device_id);
                    }
                    // Extract sensor_ids from flow steps
                    if (flow.steps) {
                        flow.steps.forEach(step => {
                            if (step.step_type === 'capture_sensors' && step.sensor_ids) {
                                step.sensor_ids.forEach(id => sensorsInFlows.add(id));
                            }
                        });
                    }
                });

                updateDeviceFilter();
                renderSensors();

            } catch (error) {
                console.error('[Sensors] Failed to load sensors:', error);
                document.getElementById('sensorsContainer').innerHTML =
                    '<p class="status error">Failed to load sensors</p>';
            }
        }

        // Update device filter dropdown
        function updateDeviceFilter() {
            const deviceFilter = document.getElementById('deviceFilter');
            const currentValue = deviceFilter.value;

            // Keep "All Devices" option
            deviceFilter.innerHTML = '<option value="">All Devices</option>';

            // Add option for each device that has sensors
            for (const [deviceId, sensors] of deviceSensors.entries()) {
                const option = document.createElement('option');
                option.value = deviceId;

                // Get device info for model name
                const device = deviceInfo.get(deviceId);
                const model = device?.model || deviceId;

                option.textContent = `${model} (${sensors.length} sensor${sensors.length !== 1 ? 's' : ''})`;
                deviceFilter.appendChild(option);
            }

            // Restore selection if possible
            if (currentValue && deviceSensors.has(currentValue)) {
                deviceFilter.value = currentValue;
            }
        }

        // Render sensors list
        function renderSensors() {
            const container = document.getElementById('sensorsContainer');
            const deviceFilter = document.getElementById('deviceFilter').value;
            const searchTerm = document.getElementById('sensorSearch').value.toLowerCase();

            // Filter sensors
            let filteredSensors = allSensors;

            if (deviceFilter) {
                filteredSensors = filteredSensors.filter(s => s.device_id === deviceFilter);
            }

            if (searchTerm) {
                filteredSensors = filteredSensors.filter(s =>
                    s.friendly_name.toLowerCase().includes(searchTerm) ||
                    s.sensor_id.toLowerCase().includes(searchTerm) ||
                    s.device_class.toLowerCase().includes(searchTerm)
                );
            }

            if (filteredSensors.length === 0) {
                container.innerHTML = '<p class="status warning">No sensors found</p>';
                return;
            }

            // Group by device + app combination
            const groupedByDeviceApp = new Map();
            for (const sensor of filteredSensors) {
                const appPackage = extractAppFromSensor(sensor);
                const groupKey = `${sensor.device_id}|${appPackage || 'unknown'}`;
                if (!groupedByDeviceApp.has(groupKey)) {
                    groupedByDeviceApp.set(groupKey, {
                        deviceId: sensor.device_id,
                        appPackage: appPackage,
                        sensors: []
                    });
                }
                groupedByDeviceApp.get(groupKey).sensors.push(sensor);
            }

            // Render grouped sensors
            let html = '';
            for (const [groupKey, group] of groupedByDeviceApp.entries()) {
                const device = deviceInfo.get(group.deviceId);
                const deviceModel = device?.model || group.deviceId;
                const appName = getAppDisplayName(group.appPackage);
                const appLabel = appName ? `<span style="background: #673AB7; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 8px;">${appName}</span>` : '';

                html += `
                    <div class="card" style="margin-bottom: 15px;">
                        <h3 style="margin-bottom: 10px; color: var(--primary-color); display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">
                            <span>${deviceModel}</span>
                            ${appLabel}
                            <span style="font-size: 14px; font-weight: normal; color: var(--text-secondary);">
                                (${group.sensors.length} sensor${group.sensors.length !== 1 ? 's' : ''})
                            </span>
                        </h3>
                        ${group.appPackage ? `<p style="margin: -5px 0 10px 0; font-size: 12px; color: var(--text-secondary);">${group.appPackage}</p>` : ''}
                        ${group.sensors.map(sensor => renderSensorCard(sensor)).join('')}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Format relative time
        function formatRelativeTime(timestamp) {
            if (!timestamp) return 'Never';
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffSec = Math.floor(diffMs / 1000);
            const diffMin = Math.floor(diffSec / 60);
            const diffHr = Math.floor(diffMin / 60);
            const diffDay = Math.floor(diffHr / 24);

            if (diffSec < 10) return 'Just now';
            if (diffSec < 60) return `${diffSec}s ago`;
            if (diffMin < 60) return `${diffMin}m ago`;
            if (diffHr < 24) return `${diffHr}h ago`;
            return `${diffDay}d ago`;
        }

        // Render individual sensor card
        function renderSensorCard(sensor) {
            const isInFlow = sensorsInFlows.has(sensor.sensor_id);
            // Check if device has any flows by stable_device_id
            const hasDeviceFlow = sensor.stable_device_id && stableIdsWithFlows.has(sensor.stable_device_id);
            const isOrphaned = !isInFlow && !hasDeviceFlow;

            // Extract app info for display
            const appPackage = extractAppFromSensor(sensor);
            const appName = getAppDisplayName(appPackage);

            const enabledBadge = sensor.enabled
                ? '<span style="background: #4CAF50; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">Enabled</span>'
                : '<span style="background: #757575; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">Disabled</span>';

            // Flow badge: In Flow (blue) > Device Has Flow (yellow) > No Flow (red)
            let flowBadge;
            if (isInFlow) {
                flowBadge = '<span style="background: #2196F3; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">In Flow</span>';
            } else if (hasDeviceFlow) {
                flowBadge = '<span style="background: #FF9800; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">Not in Flow</span>';
            } else {
                flowBadge = '<span style="background: #f44336; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">No Flow</span>';
            }

            const typeBadge = sensor.sensor_type === 'binary_sensor'
                ? '<span style="background: #FF9800; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">Binary</span>'
                : '<span style="background: #2196F3; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">Sensor</span>';

            const deviceClassBadge = sensor.device_class && sensor.device_class !== 'none'
                ? `<span style="background: #673AB7; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">${sensor.device_class}</span>`
                : '';

            // App badge - shows which app this sensor is tied to
            const appBadge = appName
                ? `<span style="background: #009688; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;" title="${appPackage}">${appName}</span>`
                : '<span style="background: #9E9E9E; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">No App</span>';

            const currentValue = sensor.current_value
                ? `${sensor.current_value}${sensor.unit_of_measurement || ''}`
                : '--';

            const lastUpdated = formatRelativeTime(sensor.last_updated);

            // Warning for orphaned sensors (no flow at all for this device)
            const orphanWarning = isOrphaned ? `
                <div style="background: #f4433620; border: 1px solid #f44336; border-radius: 6px; padding: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div style="color: #f44336;">
                        <strong>No Flow</strong> - No flows exist for this device. Create one to capture sensor values.
                    </div>
                    <a href="flow-wizard.html?device=${encodeURIComponent(sensor.device_id)}&sensor=${encodeURIComponent(sensor.sensor_id)}"
                       class="btn" style="background: #4CAF50; padding: 6px 12px; font-size: 13px; white-space: nowrap;">
                        Create Flow
                    </a>
                </div>
            ` : '';

            // Info for sensors with device flow but not added to it
            const notInFlowInfo = (!isInFlow && hasDeviceFlow) ? `
                <div style="background: #FF980020; border: 1px solid #FF9800; border-radius: 6px; padding: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div style="color: #FF9800;">
                        <strong>Not in Flow</strong> - Device has flows, but this sensor is not captured. Add it to an existing flow.
                    </div>
                    <a href="flows.html?device=${encodeURIComponent(sensor.device_id)}"
                       class="btn" style="background: #FF9800; color: white; padding: 6px 12px; font-size: 13px; white-space: nowrap;">
                        View Flows
                    </a>
                </div>
            ` : '';

            return `
                <div style="border: 1px solid ${isOrphaned ? '#f44336' : (hasDeviceFlow && !isInFlow) ? '#FF9800' : 'var(--border-color)'}; padding: 15px; margin-bottom: 10px; border-radius: 6px; background: var(--card-background);">
                    ${orphanWarning}
                    ${notInFlowInfo}
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">
                        <div style="flex: 1; min-width: 200px;">
                            <h4 style="margin: 0 0 8px 0; color: var(--text-color);">
                                ${sensor.icon ? iconRenderer.render(sensor.icon, {size: '1.3em', style: 'margin-right: 8px;'}) : ''}
                                ${sensor.friendly_name}
                            </h4>
                            <div style="display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 8px;">
                                ${enabledBadge}
                                ${flowBadge}
                                ${typeBadge}
                                ${deviceClassBadge}
                                ${appBadge}
                            </div>
                            <p style="margin: 5px 0; font-size: 13px; color: var(--text-secondary);">
                                <strong>ID:</strong> ${sensor.sensor_id}<br>
                                <strong>Update Interval:</strong> ${sensor.update_interval_seconds}s<br>
                                <strong>Extraction Method:</strong> ${sensor.extraction_rule.method}
                            </p>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            <button onclick="window.testSensor('${sensor.device_id}', '${sensor.sensor_id}')" style="padding: 6px 12px; font-size: 13px; background: var(--secondary-color);">Test</button>
                            <button onclick="window.editSensor('${sensor.device_id}', '${sensor.sensor_id}')" style="padding: 6px 12px; font-size: 13px;">Edit</button>
                            <button onclick="window.toggleSensor('${sensor.device_id}', '${sensor.sensor_id}', ${!sensor.enabled})" style="padding: 6px 12px; font-size: 13px; background: ${sensor.enabled ? '#757575' : '#4CAF50'};">
                                ${sensor.enabled ? 'Disable' : 'Enable'}
                            </button>
                            <button onclick="window.deleteSensor('${sensor.device_id}', '${sensor.sensor_id}')" style="padding: 6px 12px; font-size: 13px; background: #f44336;">Delete</button>
                        </div>
                    </div>
                    <div style="background: var(--preview-background); padding: 10px; border-radius: 4px; border: 1px solid var(--preview-border); display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 13px; color: var(--text-secondary);">Current Value:</span>
                            <strong style="font-size: 1.2em; margin-left: 8px; color: var(--primary-color);">${currentValue}</strong>
                        </div>
                        <div style="text-align: right; font-size: 12px; color: var(--text-secondary);">
                            Last Updated<br>
                            <strong>${lastUpdated}</strong>
                        </div>
                    </div>
                </div>
            `;
        }

        // Delete sensor
        window.deleteSensor = async function(deviceId, sensorId) {
            if (!confirm(`Delete sensor "${sensorId}"?\n\nThis action cannot be undone.`)) {
                return;
            }

            try {
                await apiClient.delete(`/sensors/${deviceId}/${sensorId}`);
                console.log(`[Sensors] Deleted sensor ${sensorId}`);
                await loadSensors();
            } catch (error) {
                console.error(`[Sensors] Failed to delete sensor:`, error);
                alert(`Failed to delete sensor: ${error.message}`);
            }
        };

        // Toggle sensor enabled/disabled
        window.toggleSensor = async function(deviceId, sensorId, enable) {
            try {
                // Get current sensor
                const response = await apiClient.get(`/sensors/${deviceId}/${sensorId}`);
                const sensor = response.sensor;

                // Update enabled flag
                sensor.enabled = enable;

                // Save
                await apiClient.put('/sensors', sensor);
                console.log(`[Sensors] ${enable ? 'Enabled' : 'Disabled'} sensor ${sensorId}`);
                await loadSensors();
            } catch (error) {
                console.error(`[Sensors] Failed to toggle sensor:`, error);
                alert(`Failed to ${enable ? 'enable' : 'disable'} sensor: ${error.message}`);
            }
        };

        // Test sensor extraction - Call backend API to verify extraction still works
        window.testSensor = async function(deviceId, sensorId) {
            try {
                // Get sensor details
                const response = await apiClient.get(`/sensors/${deviceId}/${sensorId}`);
                const sensor = response.sensor;

                // Test extraction with current element text
                const testResponse = await apiClient.post('/test/extract', {
                    text: sensor.source.element_text,
                    extraction_rule: sensor.extraction_rule
                });

                if (testResponse.success) {
                    alert(`✅ Test Extraction Successful!\n\nSensor: ${sensor.friendly_name}\nOriginal Text: "${sensor.source.element_text}"\nExtracted Value: "${testResponse.extracted_value}"\n\nExtraction is working correctly!`);
                } else {
                    alert(`❌ Test Extraction Failed!\n\nSensor: ${sensor.friendly_name}\nError: ${testResponse.error || 'Unknown error'}\n\nYou may need to edit the sensor's extraction rules.`);
                }
            } catch (error) {
                console.error(`[Sensors] Failed to test sensor:`, error);
                alert(`Failed to test sensor: ${error.message}`);
            }
        };

        // Edit sensor - Open sensor creator in edit mode
        window.editSensor = async function(deviceId, sensorId) {
            try {
                // Get sensor details
                const response = await apiClient.get(`/sensors/${deviceId}/${sensorId}`);
                const sensor = response.sensor;

                // Open sensor creator in edit mode
                await sensorCreator.showEdit(sensor);
            } catch (error) {
                console.error(`[Sensors] Failed to load sensor for editing:`, error);
                alert(`Failed to load sensor: ${error.message}`);
            }
        };

        // Event listeners
        document.getElementById('deviceFilter').addEventListener('change', renderSensors);
        document.getElementById('sensorSearch').addEventListener('input', renderSensors);
        document.getElementById('refreshBtn').addEventListener('click', loadSensors);

        // Initial load
        loadSensors();
    </script>
</body>
</html>
