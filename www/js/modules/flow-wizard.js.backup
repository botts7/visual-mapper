/**
 * Flow Wizard Module
 * Visual Mapper v0.0.9
 *
 * Interactive wizard for creating flows with recording mode
 * Refactored: Steps 1,2,4,5 use separate modules
 * v0.0.7: New toolbar UI, localStorage preferences, simplified layout
 * v0.0.8: Tabbed panel, loading overlay, fixed ripple offset
 * v0.0.9: Pass overlay filters to findElementAtCoordinates for container filtering
 */

import { showToast } from './toast.js?v=0.0.5';
import FlowRecorder from './flow-recorder.js?v=0.0.6';
import FlowCanvasRenderer from './flow-canvas-renderer.js?v=0.0.7';
import FlowInteractions from './flow-interactions.js?v=0.0.12';
import FlowStepManager from './flow-step-manager.js?v=0.0.5';
import LiveStream from './live-stream.js?v=0.0.13';
import ElementTree from './element-tree.js?v=0.0.4';
import APIClient from './api-client.js?v=0.0.4';
import SensorCreator from './sensor-creator.js?v=0.0.9';

// Step modules
import * as Step1 from './flow-wizard-step1.js?v=0.0.5';
import * as Step2 from './flow-wizard-step2.js?v=0.0.5';
import * as Step3 from './flow-wizard-step3.js?v=0.0.5';
import * as Step4 from './flow-wizard-step4.js?v=0.0.6';
import * as Step5 from './flow-wizard-step5.js?v=0.0.5';

// Dialog module
import * as Dialogs from './flow-wizard-dialogs.js?v=0.0.5';

// Element actions module
import * as ElementActions from './flow-wizard-element-actions.js?v=0.0.5';

// Helper to get API base (from global set by init.js)
function getApiBase() {
    return window.API_BASE || '/api';
}

class FlowWizard {
    constructor() {
        this.currentStep = 1;
        this.totalSteps = 5;
        this.selectedDevice = null;
        this.selectedApp = null;
        this.recordMode = 'execute';
        this.recorder = null;
        this.flowSteps = [];
        this.schedulerWasPaused = false;  // Track if we paused the scheduler
        this.overlayFilters = {
            showClickable: true,
            showNonClickable: false,  // Off by default - clickable elements are most useful
            showTextLabels: true,
            hideSmall: true,          // On by default - hide tiny elements
            textOnly: false,
            hideDividers: true,       // Hide full-width horizontal line elements
            hideContainers: true,     // Hide layout/container elements (View, FrameLayout, etc.)
            hideEmptyElements: true   // Hide elements without text or content-desc
        };

        // Capture state tracking (prevent concurrent captures)
        this.captureInProgress = false;
        this.currentCaptureType = null; // 'normal' or 'stitch'

        // Canvas scaling
        this.scaleMode = 'fit'; // 'fit' or '1:1'
        this.currentScale = 1.0;

        // Dev toggle for icon source display
        this.showIconSources = false;
        this.queueStatsInterval = null;

        // System apps filter toggle
        this.hideSystemApps = true; // Default: hide system apps

        // Helper modules (initialized in loadStep3)
        this.canvasRenderer = null;
        this.interactions = null;
        this.stepManager = null;

        // Live streaming (Phase 1 enhancement)
        this.captureMode = 'polling'; // 'polling' or 'streaming'
        this.streamMode = 'mjpeg'; // 'mjpeg' or 'websocket'
        this.streamQuality = 'medium'; // 'high', 'medium', 'low', 'fast'
        this.liveStream = null;

        // Gesture recording (Phase 4 enhancement)
        this.dragStart = null;
        this.isDragging = false;

        // Recording pause toggle - when paused, gestures are executed but not recorded
        this.recordingPaused = false;
        this.MIN_SWIPE_DISTANCE = 30; // Minimum pixels to count as swipe

        // Element tree (Phase 5 enhancement)
        this.elementTree = null;
        this.isTreeViewOpen = false;

        // API client and sensor creator (for advanced sensor dialog)
        this.apiClient = new APIClient();
        this.sensorCreator = new SensorCreator(this.apiClient);

        // Set callback for when sensor is created - add capture step to flow
        this.sensorCreator.onSensorCreated = (response, sensorData) => {
            Dialogs.handleSensorCreated(this, response, sensorData);
        };

        console.log('FlowWizard initialized');
        this.init();
    }

    init() {
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setup());
        } else {
            this.setup();
        }
    }

    setup() {
        this.setupNavigation();
        this.setupCleanup();
        this.pauseSchedulerForEditing();
        Step1.loadStep(this); // Load first step immediately
        console.log('FlowWizard setup complete');
    }

    /**
     * Setup cleanup handlers for page unload
     */
    setupCleanup() {
        // Resume scheduler when leaving the page
        window.addEventListener('beforeunload', () => {
            this.resumeSchedulerAfterEditing();
        });

        // Also handle visibility change (tab switch)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // Don't resume on tab switch - only on page close
            }
        });
    }

    /**
     * Pause the flow scheduler while editing flows
     * This prevents ADB contention and improves streaming performance
     */
    async pauseSchedulerForEditing() {
        try {
            const response = await this.apiClient.post('/scheduler/pause');
            if (response.success) {
                console.log('[FlowWizard] Paused flow scheduler for editing');
                this.schedulerWasPaused = true;
                this.showSchedulerStatus('paused');
            }
        } catch (e) {
            console.warn('[FlowWizard] Could not pause scheduler:', e);
        }
    }

    /**
     * Resume the flow scheduler after editing
     */
    async resumeSchedulerAfterEditing() {
        if (!this.schedulerWasPaused) return;

        try {
            await this.apiClient.post('/scheduler/resume');
            console.log('[FlowWizard] Resumed flow scheduler after editing');
            this.schedulerWasPaused = false;
        } catch (e) {
            console.warn('[FlowWizard] Could not resume scheduler:', e);
        }
    }

    /**
     * Show scheduler status indicator
     */
    showSchedulerStatus(status) {
        // Add a subtle indicator that scheduler is paused
        const nav = document.querySelector('nav');
        if (nav && status === 'paused') {
            // Check if indicator already exists
            if (!document.getElementById('scheduler-pause-indicator')) {
                const indicator = document.createElement('li');
                indicator.id = 'scheduler-pause-indicator';
                indicator.innerHTML = '<span style="color: #ff9800; font-size: 12px;" title="Flow scheduler is paused during editing">‚è∏ Flows Paused</span>';
                nav.querySelector('ul').appendChild(indicator);
            }
        } else {
            const indicator = document.getElementById('scheduler-pause-indicator');
            if (indicator) indicator.remove();
        }
    }

    /**
     * Reset wizard to initial state
     */
    reset() {
        // Stop streaming if active
        this.stopStreaming();
        this.captureMode = 'polling';

        this.currentStep = 1;
        this.selectedDevice = null;
        this.selectedApp = null;
        this.recordMode = 'execute';
        this.recorder = null;
        this.flowSteps = [];
        this.updateUI();
        Step1.loadStep(this);
    }

    setupNavigation() {
        const btnBack = document.getElementById('btnBack');
        const btnNext = document.getElementById('btnNext');

        if (btnBack) {
            btnBack.addEventListener('click', () => this.previousStep());
        }

        if (btnNext) {
            btnNext.addEventListener('click', () => this.nextStep());
        }
    }

    async nextStep() {
        // Validate current step before proceeding
        if (!await this.validateCurrentStep()) {
            return;
        }

        if (this.currentStep < this.totalSteps) {
            this.currentStep++;
            this.updateUI();
            this.loadStepContent();
        } else {
            // Last step - save flow
            this.saveFlow();
        }
    }

    previousStep() {
        if (this.currentStep > 1) {
            this.currentStep--;
            this.updateUI();
            this.loadStepContent();
        }
    }

    updateUI() {
        // Update progress indicator
        document.querySelectorAll('.wizard-progress .step').forEach((step, index) => {
            step.classList.remove('active', 'completed');
            const stepNum = index + 1;

            if (stepNum === this.currentStep) {
                step.classList.add('active');
            } else if (stepNum < this.currentStep) {
                step.classList.add('completed');
            }
        });

        // Show/hide step content
        document.querySelectorAll('.wizard-step').forEach((step, index) => {
            step.classList.toggle('active', index + 1 === this.currentStep);
        });

        // Update navigation buttons
        const btnBack = document.getElementById('btnBack');
        const btnNext = document.getElementById('btnNext');

        if (btnBack) {
            btnBack.disabled = this.currentStep === 1;
        }

        if (btnNext) {
            btnNext.textContent = this.currentStep === this.totalSteps ? 'Save Flow' : 'Next ‚Üí';
        }
    }

    async validateCurrentStep() {
        switch(this.currentStep) {
            case 1:
                if (!this.selectedDevice) {
                    showToast('Please select a device', 'error');
                    return false;
                }
                return true;

            case 2:
                if (!this.selectedApp) {
                    showToast('Please select an app', 'error');
                    return false;
                }
                // Get selected recording mode
                const modeInput = document.querySelector('input[name="recordMode"]:checked');
                if (modeInput) {
                    this.recordMode = modeInput.value;
                }
                console.log('[FlowWizard] Validated step 2:', {
                    app: this.selectedApp,
                    mode: this.recordMode
                });
                return true;

            case 3:
                if (this.flowSteps.length === 0) {
                    showToast('Please record at least one step', 'error');
                    return false;
                }
                return true;

            case 4:
                // Review step - always valid
                return true;

            case 5:
                // Settings validation
                const flowName = document.getElementById('flowName')?.value;
                if (!flowName || flowName.trim() === '') {
                    showToast('Please enter a flow name', 'error');
                    return false;
                }
                return true;

            default:
                return true;
        }
    }

    loadStepContent() {
        // Stop streaming when leaving Step 3
        if (this.currentStep !== 3 && this.captureMode === 'streaming') {
            this.stopStreaming();
            this.captureMode = 'polling';
        }

        switch(this.currentStep) {
            case 1:
                Step1.loadStep(this);
                break;
            case 2:
                Step2.loadStep(this);
                break;
            case 3:
                Step3.loadStep3(this);
                break;
            case 4:
                Step4.loadStep(this);
                break;
            case 5:
                Step5.loadStep(this);
                break;
        }
    }

    // NOTE: All steps moved to separate modules:
    // - flow-wizard-step1.js (device selection)
    // - flow-wizard-step2.js (app selection, icon detection, filtering)
    // - flow-wizard-step3.js (recording mode - UI, streaming, gestures)
    // - flow-wizard-step4.js (review & test)
    // - flow-wizard-step5.js (settings & save)

    async loadStep3() {
        console.log('Loading Step 3: Recording Mode');
        showToast(`Starting recording session...`, 'info');

        // Populate app info header
        this.populateAppInfo();

        // Phase 1 Screen Awareness: Update screen info initially
        this.updateScreenInfo();

        // Get canvas and context for rendering
        this.canvas = document.getElementById('screenshotCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.currentImage = null;

        // Initialize helper modules
        this.canvasRenderer = new FlowCanvasRenderer(this.canvas, this.ctx);
        this.canvasRenderer.setOverlayFilters(this.overlayFilters);

        // Note: Element panel replaced by ElementTree in right panel
        // ElementTree is initialized in setupElementTree()

        this.interactions = new FlowInteractions(getApiBase());

        this.stepManager = new FlowStepManager(document.getElementById('flowStepsList'));

        // Initialize FlowRecorder (pass package name, not full object)
        const packageName = this.selectedApp?.package || this.selectedApp;
        this.recorder = new FlowRecorder(this.selectedDevice, packageName, this.recordMode);

        // Setup UI event listeners
        this.setupRecordingUI();

        // Start recording session
        const started = await this.recorder.start();

        if (started) {
            // Only load initial screenshot in polling mode
            // Streaming mode will handle display via LiveStream callbacks
            if (this.captureMode !== 'streaming') {
                await this.updateScreenshotDisplay();
                // Auto-fetch full screenshot with elements after initial quick preview
                // This runs in background while user sees the quick preview
                this.refreshElements().then(() => {
                    this.updateScreenshotDisplay();
                }).catch(e => console.warn('[FlowWizard] Auto-refresh failed:', e));
            }
        }
    }

    populateAppInfo() {
        console.log('[FlowWizard] populateAppInfo() called');

        const appIcon = document.getElementById('appIcon');
        const appName = document.getElementById('appName');

        if (!appIcon || !appName) {
            console.warn('[FlowWizard] App info elements not found in DOM');
            return;
        }

        // Get app data
        const packageName = this.selectedApp?.package || this.selectedApp;
        const label = this.selectedApp?.label || packageName;

        // Set app name (truncated for toolbar)
        const shortLabel = label.length > 20 ? label.substring(0, 18) + '...' : label;
        appName.textContent = shortLabel;
        appName.title = `${label} (${packageName})`;

        // Fetch and set app icon
        const iconUrl = `${getApiBase()}/adb/app-icon/${encodeURIComponent(this.selectedDevice)}/${encodeURIComponent(packageName)}`;
        appIcon.src = iconUrl;
        appIcon.onerror = () => {
            appIcon.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="16">üì±</text></svg>';
        };

        console.log(`[FlowWizard] App info populated: ${label}`);
    }

    /**
     * Phase 1 Screen Awareness: Update current screen info in toolbar
     * Shows the current Android activity name
     */
    async updateScreenInfo() {
        const activityEl = document.getElementById('currentActivity');
        if (!activityEl) return;

        try {
            const response = await fetch(`${getApiBase()}/screen/current/${encodeURIComponent(this.selectedDevice)}`);
            if (!response.ok) {
                console.warn('[FlowWizard] Failed to get screen info');
                activityEl.textContent = '--';
                return;
            }

            const data = await response.json();
            const activityInfo = data.activity;

            if (activityInfo?.activity) {
                // Show short activity name (e.g., "MainActivity" not full path)
                const shortName = activityInfo.activity.split('.').pop();
                activityEl.textContent = shortName;
                activityEl.title = activityInfo.full_name || activityInfo.activity;
                console.log(`[FlowWizard] Screen: ${shortName} (${activityInfo.package})`);
            } else {
                activityEl.textContent = '--';
            }
        } catch (e) {
            console.warn('[FlowWizard] Error updating screen info:', e);
            activityEl.textContent = '--';
        }
    }

    setupRecordingUI() {
        // Setup capture mode toggle (Polling/Streaming)
        this.setupCaptureMode();

        // Canvas gesture handlers (mousedown/mouseup for drag detection)
        this.canvas.addEventListener('mousedown', (e) => this.onGestureStart(e));
        this.canvas.addEventListener('mouseup', (e) => this.onGestureEnd(e));
        this.canvas.addEventListener('mouseleave', () => {
            // Cancel drag if mouse leaves canvas
            if (this.isDragging) {
                this.isDragging = false;
                this.dragStart = null;
            }
        });

        // Touch support for mobile
        this.canvas.addEventListener('touchstart', (e) => this.onGestureStart(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.onGestureEnd(e));

        // Listen for zoom changes from gestures (pinch/wheel)
        this.canvas.addEventListener('zoomChanged', (e) => {
            this.updateZoomDisplay(e.detail.zoom);
        });

        // Setup hover tooltip for element preview
        this.setupHoverTooltip();

        // Setup toolbar handlers
        this.setupToolbarHandlers();

        // Setup panel toggle (mobile FAB + backdrop)
        this.setupPanelToggle();

        // Setup tab switching
        this.setupPanelTabs();

        // Setup element tree
        this.setupElementTree();

        // Setup overlay filter controls
        this.setupOverlayFilters();

        // Done recording button
        document.getElementById('btnDoneRecording')?.addEventListener('click', () => {
            this.flowSteps = this.recorder.getSteps();
            console.log('Recording complete:', this.flowSteps);
            this.nextStep();
        });

        // Clear flow button
        document.getElementById('btnClearFlow')?.addEventListener('click', () => {
            if (confirm('Clear all recorded steps?')) {
                this.recorder?.clearSteps();
                this.updateFlowStepsUI();
            }
        });
    }

    /**
     * Setup panel tab switching
     */
    setupPanelTabs() {
        const tabs = document.querySelectorAll('.panel-tab');
        const tabContents = {
            'elements': document.getElementById('tabElements'),
            'flow': document.getElementById('tabFlow')
        };

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Show corresponding content
                Object.entries(tabContents).forEach(([name, content]) => {
                    if (content) {
                        content.classList.toggle('active', name === tabName);
                    }
                });
            });
        });

        console.log('[FlowWizard] Panel tabs initialized');
    }

    /**
     * Switch to a specific tab (elements or flow)
     */
    switchToTab(tabName) {
        const tabs = document.querySelectorAll('.panel-tab');
        const tabContents = {
            'elements': document.getElementById('tabElements'),
            'flow': document.getElementById('tabFlow')
        };

        tabs.forEach(tab => {
            const isTarget = tab.dataset.tab === tabName;
            tab.classList.toggle('active', isTarget);
        });

        Object.entries(tabContents).forEach(([name, content]) => {
            if (content) {
                content.classList.toggle('active', name === tabName);
            }
        });
    }

    /**
     * Setup Quick Actions Toolbar handlers
     */
    setupToolbarHandlers() {
        // Refresh button
        document.getElementById('qabRefresh')?.addEventListener('click', async () => {
            const btn = document.getElementById('qabRefresh');
            btn.classList.add('active');
            await this.recorder.refresh();
            // Only update screenshot in polling mode - streaming updates automatically
            if (this.captureMode !== 'streaming') {
                await this.updateScreenshotDisplay();
            }
            btn.classList.remove('active');
        });

        // Back button
        document.getElementById('qabBack')?.addEventListener('click', async () => {
            await this.recorder.goBack();
            // Only update screenshot in polling mode - streaming updates automatically
            if (this.captureMode !== 'streaming') {
                this.updateScreenshotDisplay();
            }
            this.refreshAfterAction(600);
        });

        // Home button
        document.getElementById('qabHome')?.addEventListener('click', async () => {
            await this.recorder.goHome();
            // Only update screenshot in polling mode - streaming updates automatically
            if (this.captureMode !== 'streaming') {
                this.updateScreenshotDisplay();
            }
            this.refreshAfterAction(600);
        });

        // Zoom controls
        document.getElementById('qabZoomOut')?.addEventListener('click', () => this.zoomOut());
        document.getElementById('qabZoomIn')?.addEventListener('click', () => this.zoomIn());
        document.getElementById('qabFit')?.addEventListener('click', () => this.fitToScreen());
        document.getElementById('qabScale')?.addEventListener('click', () => this.toggleScale());

        // Recording toggle - pause/resume action recording
        document.getElementById('qabRecordToggle')?.addEventListener('click', () => this.toggleRecording());

        // Pull-to-refresh button - sends swipe down gesture to Android app (recordable)
        document.getElementById('qabPullRefresh')?.addEventListener('click', async () => {
            const btn = document.getElementById('qabPullRefresh');
            btn.classList.add('active');

            try {
                showToast('Sending pull-to-refresh...', 'info', 1500);

                // Use recorder's pullRefresh method which adds it as a flow step
                await this.recorder.pullRefresh();

                // Wait for app to refresh, then update screenshot
                this.refreshAfterAction(800);

                showToast('App refreshed! (Added to flow)', 'success', 1500);
            } catch (error) {
                console.error('[FlowWizard] Pull-to-refresh failed:', error);
                showToast(`Refresh failed: ${error.message}`, 'error');
            } finally {
                btn.classList.remove('active');
            }
        });

        // Restart app button - force stop and relaunch (for apps without pull-to-refresh)
        document.getElementById('qabRestartApp')?.addEventListener('click', async () => {
            const btn = document.getElementById('qabRestartApp');
            btn.classList.add('active');

            try {
                showToast('Restarting app...', 'info', 2000);

                // Use recorder's restartApp method which adds it as a flow step
                await this.recorder.restartApp();

                // Wait for app to fully restart, then update screenshot
                this.refreshAfterAction(2000);

                showToast('App restarted! (Added to flow)', 'success', 1500);
            } catch (error) {
                console.error('[FlowWizard] Restart app failed:', error);
                showToast(`Restart failed: ${error.message}`, 'error');
            } finally {
                btn.classList.remove('active');
            }
        });

        // Stitch capture button
        document.getElementById('qabStitch')?.addEventListener('click', async () => {
            const btn = document.getElementById('qabStitch');
            btn.classList.add('active');
            showToast('Starting stitch capture... This may take 30-60 seconds', 'info', 3000);

            try {
                await this.recorder.stitchCapture();
                this.updateScreenshotDisplay();
                showToast('Stitch capture complete!', 'success', 2000);
            } catch (error) {
                showToast(`Stitch capture failed: ${error.message}`, 'error', 3000);
            } finally {
                btn.classList.remove('active');
            }
        });

        // Overlay settings toggle
        document.getElementById('qabOverlay')?.addEventListener('click', () => {
            const settings = document.getElementById('overlaySettings');
            const btn = document.getElementById('qabOverlay');
            if (settings) {
                const isVisible = settings.style.display !== 'none';
                settings.style.display = isVisible ? 'none' : 'flex';
                btn?.classList.toggle('active', !isVisible);
            }
        });

        // Insert Existing Sensor button
        document.getElementById('qabInsertSensor')?.addEventListener('click', async () => {
            if (!this.recorder) {
                showToast('Start recording first (Step 3)', 'warning', 2000);
                return;
            }
            await Dialogs.showInsertSensorDialog(this);
        });

        // Insert Existing Action button
        document.getElementById('qabInsertAction')?.addEventListener('click', async () => {
            if (!this.recorder) {
                showToast('Start recording first (Step 3)', 'warning', 2000);
                return;
            }
            await Dialogs.showInsertActionDialog(this);
        });

        // Reconnect stream button
        document.getElementById('qabReconnect')?.addEventListener('click', () => {
            this.reconnectStream();
        });

        // Panel toggle button (desktop)
        document.getElementById('qabPanel')?.addEventListener('click', () => {
            this.toggleRightPanel();
        });

        console.log('[FlowWizard] Toolbar handlers initialized');
    }

    /**
     * Setup panel toggle for mobile (FAB + backdrop)
     */
    setupPanelToggle() {
        const fab = document.getElementById('panelToggleFab');
        const backdrop = document.getElementById('panelBackdrop');
        const rightPanel = document.getElementById('rightPanel');

        fab?.addEventListener('click', () => {
            rightPanel?.classList.toggle('open');
            backdrop?.classList.toggle('visible');
        });

        backdrop?.addEventListener('click', () => {
            rightPanel?.classList.remove('open');
            backdrop?.classList.remove('visible');
        });

        console.log('[FlowWizard] Panel toggle initialized');
    }

    /**
     * Toggle right panel visibility (for desktop)
     */
    toggleRightPanel() {
        const rightPanel = document.getElementById('rightPanel');
        const btn = document.getElementById('qabPanel');

        if (rightPanel) {
            const isHidden = rightPanel.style.display === 'none';
            rightPanel.style.display = isHidden ? 'flex' : 'none';
            btn?.classList.toggle('active', isHidden);
        }
    }

    setupOverlayFilters() {
        const filterIds = {
            showClickable: 'filterClickable',
            showNonClickable: 'filterNonClickable',
            showTextLabels: 'filterTextLabels',
            hideSmall: 'filterMinSize',
            hideDividers: 'filterDividers',
            hideContainers: 'filterContainers',
            hideEmptyElements: 'filterEmptyElements'
        };

        Object.entries(filterIds).forEach(([filterName, elementId]) => {
            const checkbox = document.getElementById(elementId);
            if (!checkbox) {
                console.warn(`[FlowWizard] Filter checkbox not found: ${elementId}`);
                return;
            }

            checkbox.addEventListener('change', () => {
                this.overlayFilters[filterName] = checkbox.checked;
                // Update canvas renderer filters
                if (this.canvasRenderer) {
                    this.canvasRenderer.setOverlayFilters(this.overlayFilters);
                }
                console.log(`[FlowWizard] ${filterName} = ${checkbox.checked}`);

                // Only refresh display in polling mode WITH valid screenshot data
                if (this.captureMode === 'streaming') {
                    // Streaming mode: just update LiveStream overlay settings
                    if (this.liveStream) {
                        this.liveStream.setOverlaysVisible(
                            this.overlayFilters.showClickable || this.overlayFilters.showNonClickable
                        );
                        this.liveStream.setTextLabelsVisible(this.overlayFilters.showTextLabels);
                        this.liveStream.setHideContainers(this.overlayFilters.hideContainers);
                        this.liveStream.setHideEmptyElements(this.overlayFilters.hideEmptyElements);
                    }
                } else if (this.recorder?.currentScreenshot) {
                    // Polling mode: only redraw if we have valid screenshot data
                    this.updateScreenshotDisplay();
                }
            });

            // Set initial state
            checkbox.checked = this.overlayFilters[filterName];
        });

        // Setup refresh interval dropdown
        const refreshSelect = document.getElementById('elementRefreshInterval');
        if (refreshSelect) {
            refreshSelect.addEventListener('change', () => {
                const newInterval = parseInt(refreshSelect.value);
                console.log(`[FlowWizard] Refresh interval changed to ${newInterval / 1000}s`);

                // Restart auto-refresh with new interval if streaming
                if (this.captureMode === 'streaming' && this.liveStream?.connectionState === 'connected') {
                    this.startElementAutoRefresh();
                }
            });
        }

        console.log('[FlowWizard] Overlay filters initialized');
    }

    /**
     * Setup capture mode toggle (Polling vs Streaming)
     */
    setupCaptureMode() {
        const captureModeSelect = document.getElementById('captureMode');
        const streamModeSelect = document.getElementById('streamMode');
        const qualitySelect = document.getElementById('streamQuality');

        // Load saved preferences from localStorage
        const savedMode = localStorage.getItem('flowWizard.captureMode') || 'polling';
        const savedStreamMode = localStorage.getItem('flowWizard.streamMode') || 'mjpeg';
        const savedQuality = localStorage.getItem('flowWizard.streamQuality') || 'medium';

        // Handle capture mode change (select dropdown)
        if (captureModeSelect) {
            captureModeSelect.value = savedMode;
            this.setCaptureMode(savedMode);

            captureModeSelect.addEventListener('change', (e) => {
                const mode = e.target.value;
                localStorage.setItem('flowWizard.captureMode', mode);
                this.setCaptureMode(mode);
            });
        }

        // Handle stream mode change (mjpeg vs websocket)
        if (streamModeSelect) {
            streamModeSelect.value = savedStreamMode;
            this.streamMode = savedStreamMode;

            streamModeSelect.addEventListener('change', (e) => {
                this.streamMode = e.target.value;
                localStorage.setItem('flowWizard.streamMode', e.target.value);
                // If streaming, restart with new mode
                if (this.captureMode === 'streaming' && this.liveStream?.isActive()) {
                    this.startStreaming();
                }
            });
        }

        // Handle quality change
        if (qualitySelect) {
            qualitySelect.value = savedQuality;
            this.streamQuality = savedQuality;

            qualitySelect.addEventListener('change', (e) => {
                this.streamQuality = e.target.value;
                localStorage.setItem('flowWizard.streamQuality', e.target.value);
                // If streaming, restart with new quality
                if (this.captureMode === 'streaming' && this.liveStream?.isActive()) {
                    this.startStreaming();
                }
            });
        }

        console.log('[FlowWizard] Capture mode controls initialized');
    }

    /**
     * Set capture mode (polling or streaming)
     */
    setCaptureMode(mode) {
        const streamModeSelect = document.getElementById('streamMode');
        const qualitySelect = document.getElementById('streamQuality');

        // Get buttons that are mode-specific
        const refreshBtn = document.getElementById('qabRefresh');
        const stitchBtn = document.getElementById('qabStitch');
        const zoomOutBtn = document.getElementById('qabZoomOut');
        const zoomInBtn = document.getElementById('qabZoomIn');
        const scaleBtn = document.getElementById('qabScale');

        if (mode === 'streaming') {
            this.captureMode = 'streaming';
            if (streamModeSelect) streamModeSelect.disabled = false;
            if (qualitySelect) qualitySelect.disabled = false;

            // Disable polling-only buttons in streaming mode
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.title = 'Refresh not available in streaming mode';
            }
            if (stitchBtn) {
                stitchBtn.disabled = true;
                stitchBtn.title = 'Stitch not available in streaming mode';
            }
            // Zoom controls work in streaming mode

            this.startStreaming();
        } else {
            this.captureMode = 'polling';
            if (streamModeSelect) streamModeSelect.disabled = true;
            if (qualitySelect) qualitySelect.disabled = true;

            // Enable polling buttons
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.title = 'Refresh Screen';
            }
            if (stitchBtn) {
                stitchBtn.disabled = false;
                stitchBtn.title = 'Full Page Capture';
            }

            this.stopStreaming();
        }

        console.log(`[FlowWizard] Capture mode: ${mode}`);
    }

    /**
     * Start live streaming
     */
    startStreaming() {
        if (!this.selectedDevice) {
            showToast('No device selected', 'error');
            return;
        }

        // Show loading indicator immediately
        this.showLoadingOverlay('Connecting to device...');

        // Pre-fetch elements while stream is connecting (faster startup)
        this.refreshElements().catch(e => console.warn('[FlowWizard] Pre-fetch elements failed:', e));

        // Stop any existing stream
        this.stopStreaming();

        // Initialize LiveStream if needed
        if (!this.liveStream) {
            this.liveStream = new LiveStream(this.canvas);

            // Handle each frame - hide loading and reapply zoom
            this.liveStream.onFrame = (data) => {
                this.hideLoadingOverlay();
                // Reapply zoom after each frame to ensure CSS sizing persists
                // This is needed because LiveStream updates canvas bitmap dimensions
                if (this.canvasRenderer) {
                    this.canvasRenderer.applyZoom();
                }
            };

            // Wire up callbacks
            this.liveStream.onConnect = () => {
                this.updateStreamStatus('connected', 'Live');
                this.showLoadingOverlay('Loading stream...');
                showToast('Streaming started', 'success', 2000);
                // Fetch elements (may already be loaded from pre-fetch)
                this.refreshElements();
                // Start periodic element refresh (every 3 seconds)
                this.startElementAutoRefresh();
            };

            this.liveStream.onDisconnect = () => {
                this.updateStreamStatus('disconnected', 'Offline');
                showToast('Device disconnected', 'warning', 3000);
            };

            this.liveStream.onConnectionStateChange = (state, attempts) => {
                switch (state) {
                    case 'connecting':
                        this.updateStreamStatus('connecting', 'Connecting...');
                        break;
                    case 'reconnecting':
                        this.updateStreamStatus('reconnecting', `Retry ${attempts}...`);
                        if (attempts === 1) {
                            showToast('Connection lost, reconnecting...', 'warning', 3000);
                        }
                        break;
                    case 'connected':
                        this.updateStreamStatus('connected', 'Live');
                        break;
                    case 'disconnected':
                        this.updateStreamStatus('disconnected', 'Offline');
                        if (attempts >= 10) {
                            showToast('Device connection failed after 10 attempts', 'error', 5000);
                        }
                        break;
                }
            };

            this.liveStream.onError = (error) => {
                console.error('[FlowWizard] Stream error:', error);
                showToast(`Stream error: ${error.message || 'Connection failed'}`, 'error', 3000);
            };

            // Show FPS and capture time in status (updates every few frames)
            this.liveStream.onMetricsUpdate = (metrics) => {
                if (this.captureMode === 'streaming' && this.liveStream?.connectionState === 'connected') {
                    // Determine connection quality based on capture time
                    const captureTime = metrics.captureTime || 0;
                    let quality = 'connected'; // CSS class
                    let statusText = `${metrics.fps} FPS`;

                    if (captureTime > 0) {
                        statusText = `${metrics.fps} FPS (${captureTime}ms)`;

                        // Quality indicator based on capture time
                        if (captureTime > 1000) {
                            quality = 'slow'; // > 1 second = very slow
                        } else if (captureTime > 500) {
                            quality = 'ok'; // 500ms-1s = acceptable but slow
                        } else {
                            quality = 'good'; // < 500ms = good
                        }
                    }

                    this.updateStreamStatus(quality, statusText);

                    // Warn user once if connection is very slow (only on first slow frame detection)
                    if (captureTime > 2000 && !this._slowConnectionWarned) {
                        this._slowConnectionWarned = true;
                        showToast('Slow connection - try USB for better performance', 'warning', 5000);
                    }
                }
            };

            // Apply current overlay settings
            this.liveStream.setOverlaysVisible(this.overlayFilters.showClickable || this.overlayFilters.showNonClickable);
            this.liveStream.setTextLabelsVisible(this.overlayFilters.showTextLabels);
            this.liveStream.setHideContainers(this.overlayFilters.hideContainers);
            this.liveStream.setHideEmptyElements(this.overlayFilters.hideEmptyElements);
        }

        // Start streaming with selected mode (mjpeg or websocket)
        this.liveStream.start(this.selectedDevice, this.streamMode, this.streamQuality);
        this.updateStreamStatus('connecting', 'Connecting...');
    }

    /**
     * Stop live streaming
     */
    stopStreaming() {
        // Stop element auto-refresh
        this.stopElementAutoRefresh();

        if (this.liveStream) {
            this.liveStream.stop();
        }
        this.updateStreamStatus('', '');
    }

    /**
     * Reconnect the stream (stop and restart)
     * Resets slow connection warning flag
     */
    reconnectStream() {
        if (this.captureMode !== 'streaming') {
            showToast('Not in streaming mode', 'info', 2000);
            return;
        }

        showToast('Reconnecting stream...', 'info', 2000);

        // Reset slow connection warning
        this._slowConnectionWarned = false;

        // Stop and restart the stream
        this.stopStreaming();

        // Small delay before reconnecting
        setTimeout(() => {
            this.startStreaming();
        }, 500);
    }

    /**
     * Start periodic element auto-refresh (for streaming mode)
     */
    startElementAutoRefresh() {
        // Clear any existing interval
        this.stopElementAutoRefresh();

        // Get configurable interval from dropdown (default 3000ms)
        const intervalSelect = document.getElementById('elementRefreshInterval');
        const intervalMs = intervalSelect ? parseInt(intervalSelect.value) : 3000;

        // Start refresh with configured interval
        this.elementRefreshIntervalTimer = setInterval(() => {
            if (this.captureMode === 'streaming' && this.liveStream?.connectionState === 'connected') {
                // Log with timestamp so user can verify actual interval
                const now = new Date().toLocaleTimeString();
                console.log(`[FlowWizard] Timer tick at ${now} - refreshing elements...`);
                this.refreshElements();
            }
        }, intervalMs);

        console.log(`[FlowWizard] Element auto-refresh started (${intervalMs / 1000}s interval)`);
    }

    /**
     * Stop periodic element auto-refresh
     */
    stopElementAutoRefresh() {
        if (this.elementRefreshIntervalTimer) {
            clearInterval(this.elementRefreshIntervalTimer);
            this.elementRefreshIntervalTimer = null;
            console.log('[FlowWizard] Element auto-refresh stopped');
        }
    }

    /**
     * Update stream status display
     */
    updateStreamStatus(className, text) {
        const statusEl = document.getElementById('connectionStatus');
        if (statusEl) {
            statusEl.className = `connection-status ${className}`;
            statusEl.textContent = text;
        }
    }

    /**
     * Refresh elements in background
     * In streaming mode: uses fast elements-only endpoint
     * In polling mode: fetches full screenshot with elements
     */
    async refreshElements() {
        if (!this.selectedDevice) return;

        try {
            let elements = [];

            if (this.captureMode === 'streaming') {
                // Fast path: elements-only endpoint (no screenshot capture)
                const response = await fetch(`${getApiBase()}/adb/elements/${encodeURIComponent(this.selectedDevice)}`);
                if (!response.ok) return;

                const data = await response.json();
                elements = data.elements || [];

                // Update device dimensions for proper overlay scaling
                if (data.device_width && data.device_height && this.liveStream) {
                    this.liveStream.setDeviceDimensions(data.device_width, data.device_height);
                }

                console.log(`[FlowWizard] Fast elements refresh: ${elements.length} elements`);
            } else {
                // Polling mode: full screenshot with elements
                const response = await fetch(`${getApiBase()}/adb/screenshot`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: this.selectedDevice, quick: false })
                });

                if (!response.ok) return;

                const data = await response.json();
                elements = data.elements || [];

                // Extract device dimensions from screenshot (native resolution)
                if (data.screenshot && this.liveStream) {
                    const img = new Image();
                    img.onload = () => {
                        this.liveStream.deviceWidth = img.width;
                        this.liveStream.deviceHeight = img.height;
                        console.log(`[FlowWizard] Device dimensions: ${img.width}x${img.height}`);
                    };
                    img.src = 'data:image/png;base64,' + data.screenshot;
                }

                // Store metadata if recorder exists (for updateScreenshotDisplay)
                if (this.recorder) {
                    this.recorder.currentScreenshot = data.screenshot;
                    this.recorder.screenshotMetadata = {
                        elements: elements,
                        timestamp: data.timestamp,
                        width: this.recorder.screenshotMetadata?.width,
                        height: this.recorder.screenshotMetadata?.height,
                        quick: false
                    };
                }
            }

            // Update LiveStream elements for overlay
            if (this.liveStream) {
                this.liveStream.elements = elements;
            }

            // Update element tree
            this.updateElementTree(elements);
            this.updateElementCount(elements.length);

            console.log(`[FlowWizard] Elements refreshed: ${elements.length} elements`);
        } catch (error) {
            console.warn('[FlowWizard] Failed to refresh elements:', error);
        }
    }

    /**
     * Auto-refresh elements after an action (with delay)
     * Used in streaming mode to update element overlays after tap/swipe
     */
    async refreshAfterAction(delayMs = 500) {
        if (this.captureMode !== 'streaming') return;

        setTimeout(async () => {
            try {
                await this.refreshElements();
            } catch (e) {
                console.warn('[FlowWizard] Auto-refresh after action failed:', e);
            }
        }, delayMs);
    }

    /**
     * Setup hover tooltip for element preview
     */
    setupHoverTooltip() {
        this.hoveredElement = null;
        const hoverTooltip = document.getElementById('hoverTooltip');
        const container = document.getElementById('screenshotContainer');

        if (!hoverTooltip || !container) return;

        // Handle mouse move on canvas
        this.canvas.addEventListener('mousemove', (e) => {
            this.handleCanvasHover(e, hoverTooltip, container);
        });

        // Hide tooltip when mouse leaves canvas
        this.canvas.addEventListener('mouseleave', () => {
            this.hoveredElement = null;
            this.hideHoverTooltip(hoverTooltip);
        });

        console.log('[FlowWizard] Hover tooltip initialized');
    }

    /**
     * Handle mouse movement over canvas for element hover
     */
    handleCanvasHover(e, hoverTooltip, container) {
        const elements = this.recorder?.screenshotMetadata?.elements || this.liveStream?.elements || [];
        if (elements.length === 0) {
            this.hideHoverTooltip(hoverTooltip);
            return;
        }

        // Get canvas coordinates (CSS display coords ‚Üí canvas bitmap coords)
        const rect = this.canvas.getBoundingClientRect();
        const cssToCanvas = this.canvas.width / rect.width;
        const canvasX = (e.clientX - rect.left) * cssToCanvas;
        const canvasY = (e.clientY - rect.top) * cssToCanvas;

        // Convert to device coordinates (use appropriate converter based on mode)
        let deviceCoords;
        if (this.captureMode === 'streaming' && this.liveStream) {
            deviceCoords = this.liveStream.canvasToDevice(canvasX, canvasY);
        } else {
            deviceCoords = this.canvasRenderer.canvasToDevice(canvasX, canvasY);
        }

        // Container classes to filter out (same as FlowInteractions)
        const containerClasses = [
            'android.view.View', 'android.view.ViewGroup', 'android.widget.FrameLayout',
            'android.widget.LinearLayout', 'android.widget.RelativeLayout',
            'android.widget.ScrollView', 'android.widget.HorizontalScrollView',
            'androidx.constraintlayout.widget.ConstraintLayout',
            'androidx.recyclerview.widget.RecyclerView', 'androidx.cardview.widget.CardView'
        ];

        // Find elements at hover position (filter containers)
        let elementsAtPoint = [];
        for (let i = elements.length - 1; i >= 0; i--) {
            const el = elements[i];
            if (!el.bounds) continue;

            // Skip containers if filter is enabled
            if (this.overlayFilters?.hideContainers && el.class && containerClasses.includes(el.class)) {
                continue;
            }

            // Skip empty elements if filter is enabled
            if (this.overlayFilters?.hideEmptyElements) {
                const hasText = el.text && el.text.trim();
                const hasContentDesc = el['content-desc'] && el['content-desc'].trim();
                const hasResourceId = el['resource-id'] && el['resource-id'].trim();
                if (!hasText && !hasContentDesc && !(el.clickable && hasResourceId)) {
                    continue;
                }
            }

            const b = el.bounds;
            if (deviceCoords.x >= b.x && deviceCoords.x <= b.x + b.width &&
                deviceCoords.y >= b.y && deviceCoords.y <= b.y + b.height) {
                elementsAtPoint.push(el);
            }
        }

        // Prioritize: elements with text first, then clickable, then smallest area
        let foundElement = null;
        if (elementsAtPoint.length > 0) {
            // Prefer elements with text
            const withText = elementsAtPoint.filter(el => el.text?.trim() || el['content-desc']?.trim());
            const clickable = elementsAtPoint.filter(el => el.clickable);
            const candidates = withText.length > 0 ? withText : (clickable.length > 0 ? clickable : elementsAtPoint);

            foundElement = candidates.reduce((smallest, el) => {
                const area = el.bounds.width * el.bounds.height;
                const smallestArea = smallest.bounds.width * smallest.bounds.height;
                return area < smallestArea ? el : smallest;
            });
        }

        // Check if element changed (compare by bounds, not object reference)
        const isSameElement = foundElement && this.hoveredElement &&
            foundElement.bounds?.x === this.hoveredElement.bounds?.x &&
            foundElement.bounds?.y === this.hoveredElement.bounds?.y &&
            foundElement.bounds?.width === this.hoveredElement.bounds?.width;

        if (foundElement && !isSameElement) {
            // New element - rebuild tooltip content
            this.hoveredElement = foundElement;
            this.showHoverTooltip(e, foundElement, hoverTooltip, container);
            this.highlightHoveredElement(foundElement);
        } else if (!foundElement && this.hoveredElement) {
            // No longer hovering any element
            this.hoveredElement = null;
            this.hideHoverTooltip(hoverTooltip);
            this.clearHoverHighlight();
        }

        // ALWAYS update position when hovering an element (fixes cursor following)
        if (foundElement) {
            this.updateTooltipPosition(e, hoverTooltip, container);
        }
    }

    /**
     * Show hover tooltip with element info
     */
    showHoverTooltip(e, element, hoverTooltip, container) {
        const header = hoverTooltip.querySelector('.tooltip-header');
        const body = hoverTooltip.querySelector('.tooltip-body');

        // Header: element text or class name (handle hyphenated property names)
        const displayName = element.text?.trim() ||
                           element['content-desc']?.trim() ||
                           element.content_desc?.trim() ||
                           element.class?.split('.').pop() ||
                           'Element';
        header.textContent = displayName;

        // Body: element details
        const clickableBadge = element.clickable
            ? '<span class="clickable-badge">Clickable</span>'
            : '<span class="not-clickable-badge">Not Clickable</span>';

        let bodyHtml = `<div class="tooltip-row"><span class="tooltip-label">Class:</span><span class="tooltip-value">${element.class?.split('.').pop() || '-'}</span></div>`;

        // Handle both hyphenated and underscore property names
        const resourceId = element['resource-id'] || element.resource_id;
        if (resourceId) {
            const resId = resourceId.split('/').pop() || resourceId;
            bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">ID:</span><span class="tooltip-value">${resId}</span></div>`;
        }

        if (element.bounds) {
            bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">Size:</span><span class="tooltip-value">${element.bounds.width}x${element.bounds.height}</span></div>`;
        }

        bodyHtml += `<div class="tooltip-row"><span class="tooltip-label">Status:</span><span class="tooltip-value">${clickableBadge}</span></div>`;

        body.innerHTML = bodyHtml;

        this.updateTooltipPosition(e, hoverTooltip, container);
        hoverTooltip.style.display = 'block';
    }

    /**
     * Update tooltip position near cursor
     */
    updateTooltipPosition(e, hoverTooltip, container) {
        const containerRect = container.getBoundingClientRect();

        // Account for container scroll offset
        const scrollLeft = container.scrollLeft || 0;
        const scrollTop = container.scrollTop || 0;

        // Position tooltip near cursor (add scroll offset for scrolled containers)
        let x = e.clientX - containerRect.left + scrollLeft + 15;
        let y = e.clientY - containerRect.top + scrollTop + 15;

        // Get tooltip dimensions (use cached if not visible yet)
        const tooltipWidth = hoverTooltip.offsetWidth || 280;
        const tooltipHeight = hoverTooltip.offsetHeight || 100;

        // Keep tooltip within visible viewport (not scrolled content)
        const visibleWidth = containerRect.width;
        const visibleHeight = containerRect.height;

        // Flip to left if would overflow right
        if (x - scrollLeft + tooltipWidth > visibleWidth - 10) {
            x = e.clientX - containerRect.left + scrollLeft - tooltipWidth - 15;
        }
        // Flip to top if would overflow bottom
        if (y - scrollTop + tooltipHeight > visibleHeight - 10) {
            y = e.clientY - containerRect.top + scrollTop - tooltipHeight - 15;
        }

        // Ensure minimum position
        x = Math.max(scrollLeft + 5, x);
        y = Math.max(scrollTop + 5, y);

        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
    }

    /**
     * Hide hover tooltip
     */
    hideHoverTooltip(hoverTooltip) {
        if (hoverTooltip) {
            hoverTooltip.style.display = 'none';
        }
    }

    /**
     * Highlight hovered element using CSS overlay (no canvas re-render)
     * Handles both polling mode (screenshot) and streaming mode (live stream)
     */
    highlightHoveredElement(element) {
        const container = document.getElementById('screenshotContainer');
        if (!container || !element?.bounds) {
            this.clearHoverHighlight();
            return;
        }

        // Create or reuse highlight overlay
        let highlight = document.getElementById('hoverHighlight');
        if (!highlight) {
            highlight = document.createElement('div');
            highlight.id = 'hoverHighlight';
            highlight.className = 'hover-highlight';
            container.appendChild(highlight);
        }

        // Calculate position relative to canvas
        const canvasRect = this.canvas.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const offsetX = canvasRect.left - containerRect.left + container.scrollLeft;
        const offsetY = canvasRect.top - containerRect.top + container.scrollTop;

        // Get CSS scale (canvas bitmap size to display size)
        const cssScale = canvasRect.width / this.canvas.width;

        // In streaming mode, element bounds are in device coords, canvas may be at lower res
        // We need to scale: device coords ‚Üí canvas coords ‚Üí CSS display coords
        let deviceToCanvasScale = 1;
        if (this.captureMode === 'streaming' && this.liveStream) {
            // Scale from device resolution to canvas resolution
            deviceToCanvasScale = this.canvas.width / this.liveStream.deviceWidth;
        }

        const b = element.bounds;
        // First scale from device to canvas, then from canvas to CSS display
        const totalScale = deviceToCanvasScale * cssScale;
        const x = b.x * totalScale + offsetX;
        const y = b.y * totalScale + offsetY;
        const w = b.width * totalScale;
        const h = b.height * totalScale;

        highlight.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${w}px;
            height: ${h}px;
            border: 2px solid #00ffff;
            border-radius: 4px;
            background: rgba(0, 255, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            transition: all 0.1s ease-out;
        `;
    }

    /**
     * Clear hover highlight overlay
     */
    clearHoverHighlight() {
        const highlight = document.getElementById('hoverHighlight');
        if (highlight) {
            highlight.remove();
        }
    }

    // ==========================================
    // Phase 4: Gesture Recording Methods
    // ==========================================

    /**
     * Handle gesture start (mousedown/touchstart)
     */
    onGestureStart(e) {
        // Ignore during pinch gestures
        if (this.canvasRenderer?.isPinching) return;

        e.preventDefault();

        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        // Convert CSS coordinates to canvas bitmap coordinates
        const cssToCanvas = this.canvas.width / rect.width;
        this.dragStart = {
            canvasX: (clientX - rect.left) * cssToCanvas,
            canvasY: (clientY - rect.top) * cssToCanvas,
            timestamp: Date.now()
        };
        this.isDragging = true;
    }

    /**
     * Handle gesture end (mouseup/touchend)
     */
    async onGestureEnd(e) {
        if (!this.isDragging || !this.dragStart) return;

        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.changedTouches) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        // Convert CSS coordinates to canvas bitmap coordinates
        const cssToCanvas = this.canvas.width / rect.width;
        const endCanvasX = (clientX - rect.left) * cssToCanvas;
        const endCanvasY = (clientY - rect.top) * cssToCanvas;

        // Calculate distance
        const dx = endCanvasX - this.dragStart.canvasX;
        const dy = endCanvasY - this.dragStart.canvasY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        this.isDragging = false;

        const container = document.getElementById('screenshotContainer');

        // Get canvas offset within container for accurate ripple/path position
        const canvasRect = this.canvas.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const canvasOffsetX = canvasRect.left - containerRect.left + container.scrollLeft;
        const canvasOffsetY = canvasRect.top - containerRect.top + container.scrollTop;

        // CSS scale factor: canvas bitmap coords to display coords (accounts for zoom)
        const cssScale = canvasRect.width / this.canvas.width;

        if (distance < this.MIN_SWIPE_DISTANCE) {
            // It's a tap
            console.log(`[FlowWizard] Tap at canvas (${this.dragStart.canvasX}, ${this.dragStart.canvasY})`);

            // Show tap ripple effect (convert canvas coords to display coords, then add offset)
            const rippleX = this.dragStart.canvasX * cssScale + canvasOffsetX;
            const rippleY = this.dragStart.canvasY * cssScale + canvasOffsetY;
            this.showTapRipple(container, rippleX, rippleY);

            // Handle element click (existing logic)
            await this.handleElementClick(this.dragStart.canvasX, this.dragStart.canvasY);
        } else {
            // It's a swipe
            console.log(`[FlowWizard] Swipe from (${this.dragStart.canvasX},${this.dragStart.canvasY}) to (${endCanvasX},${endCanvasY})`);

            // Show swipe path visualization (convert canvas coords to display coords, then add offset)
            this.showSwipePath(container,
                this.dragStart.canvasX * cssScale + canvasOffsetX,
                this.dragStart.canvasY * cssScale + canvasOffsetY,
                endCanvasX * cssScale + canvasOffsetX,
                endCanvasY * cssScale + canvasOffsetY);

            // Execute swipe on device
            await this.executeSwipeGesture(
                this.dragStart.canvasX, this.dragStart.canvasY,
                endCanvasX, endCanvasY
            );
        }

        this.dragStart = null;
    }

    /**
     * Execute swipe gesture on device
     */
    async executeSwipeGesture(startCanvasX, startCanvasY, endCanvasX, endCanvasY) {
        // Convert canvas coordinates to device coordinates (use appropriate converter)
        let startDevice, endDevice;
        if (this.captureMode === 'streaming' && this.liveStream) {
            startDevice = this.liveStream.canvasToDevice(startCanvasX, startCanvasY);
            endDevice = this.liveStream.canvasToDevice(endCanvasX, endCanvasY);
        } else {
            startDevice = this.canvasRenderer.canvasToDevice(startCanvasX, startCanvasY);
            endDevice = this.canvasRenderer.canvasToDevice(endCanvasX, endCanvasY);
        }

        console.log(`[FlowWizard] Executing swipe: (${startDevice.x},${startDevice.y}) ‚Üí (${endDevice.x},${endDevice.y})`);

        try {
            const response = await fetch(`${getApiBase()}/adb/swipe`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: this.selectedDevice,
                    x1: startDevice.x,
                    y1: startDevice.y,
                    x2: endDevice.x,
                    y2: endDevice.y,
                    duration: 300
                })
            });

            if (!response.ok) {
                throw new Error('Failed to execute swipe');
            }

            // Add swipe step to flow (unless recording is paused)
            if (!this.recordingPaused) {
                this.recorder.addStep({
                    step_type: 'swipe',
                    start_x: startDevice.x,
                    start_y: startDevice.y,
                    end_x: endDevice.x,
                    end_y: endDevice.y,
                    duration: 300,
                    description: `Swipe from (${startDevice.x},${startDevice.y}) to (${endDevice.x},${endDevice.y})`
                });
                showToast('Swipe recorded', 'success', 1500);
            } else {
                showToast('Swipe executed (not recorded)', 'info', 1500);
            }

            // Clear stale elements immediately (video updates faster than elements API)
            if (this.captureMode === 'streaming' && this.liveStream) {
                this.liveStream.elements = [];
            }

            // Refresh elements after swipe (give device time to settle)
            this.refreshAfterAction(800);

            // Update screenshot in polling mode
            if (this.captureMode === 'polling') {
                await this.recorder.wait(400);
                await this.recorder.captureScreenshot();
                this.updateScreenshotDisplay();
            }

        } catch (error) {
            console.error('[FlowWizard] Swipe failed:', error);
            showToast(`Swipe failed: ${error.message}`, 'error');
        }
    }

    /**
     * Show animated tap ripple at position
     */
    showTapRipple(container, x, y) {
        // Create ripple ring
        const ring = document.createElement('div');
        ring.className = 'tap-ripple-ring';
        ring.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 3px solid #3b82f6;
            border-radius: 50%;
            pointer-events: none;
            animation: tapRippleExpand 0.5s ease-out forwards;
            z-index: 100;
        `;
        container.appendChild(ring);

        // Create second delayed ring for effect
        setTimeout(() => {
            const ring2 = document.createElement('div');
            ring2.className = 'tap-ripple-ring';
            ring2.style.cssText = ring.style.cssText;
            ring2.style.animationDelay = '0.1s';
            container.appendChild(ring2);
            setTimeout(() => ring2.remove(), 600);
        }, 100);

        // Remove after animation
        setTimeout(() => ring.remove(), 600);
    }

    /**
     * Show animated swipe path from start to end
     */
    showSwipePath(container, startX, startY, endX, endY) {
        // Create or reuse swipe path container
        let swipeContainer = document.getElementById('swipePathContainer');
        if (!swipeContainer) {
            swipeContainer = document.createElement('div');
            swipeContainer.id = 'swipePathContainer';
            swipeContainer.className = 'swipe-path';
            swipeContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 100;
            `;
            container.appendChild(swipeContainer);
        }

        // Calculate SVG dimensions
        const width = container.offsetWidth;
        const height = container.offsetHeight;

        // Create SVG with animated line
        swipeContainer.innerHTML = `
            <svg width="${width}" height="${height}" style="position: absolute; top: 0; left: 0;">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" class="swipe-arrow" fill="#22c55e"/>
                    </marker>
                </defs>
                <line x1="${startX}" y1="${startY}" x2="${endX}" y2="${endY}"
                      stroke="#22c55e" stroke-width="3" stroke-linecap="round"
                      class="swipe-line" marker-end="url(#arrowhead)"
                      stroke-dasharray="1000" stroke-dashoffset="1000"
                      style="animation: swipeLineDraw 0.3s ease-out forwards;"/>
            </svg>
        `;

        // Add start dot
        const startDot = document.createElement('div');
        startDot.className = 'swipe-dot swipe-dot-start';
        startDot.style.cssText = `
            position: absolute;
            left: ${startX}px;
            top: ${startY}px;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            margin-top: -6px;
            background: #22c55e;
            border-radius: 50%;
            pointer-events: none;
        `;
        swipeContainer.appendChild(startDot);

        // Add end dot
        const endDot = document.createElement('div');
        endDot.className = 'swipe-dot swipe-dot-end';
        endDot.style.cssText = `
            position: absolute;
            left: ${endX}px;
            top: ${endY}px;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            margin-top: -6px;
            background: #22c55e;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
        `;
        swipeContainer.appendChild(endDot);

        swipeContainer.style.display = 'block';

        // Auto-hide after animation
        setTimeout(() => {
            swipeContainer.style.display = 'none';
            swipeContainer.innerHTML = '';
        }, 800);
    }

    // ==========================================
    // Phase 5: Element Tree Methods
    // ==========================================

    /**
     * Setup element tree panel
     */
    setupElementTree() {
        const container = document.getElementById('elementTreeContainer');
        if (!container) {
            console.warn('[FlowWizard] Element tree container not found');
            return;
        }

        this.elementTree = new ElementTree(container, {
            onTap: (element) => this.handleTreeTap(element),
            onSensor: (element) => this.handleTreeSensor(element),
            onHighlight: (element) => this.highlightHoveredElement(element)
        });

        // Wire up tree search
        const searchInput = document.getElementById('treeSearchInput');
        searchInput?.addEventListener('input', (e) => {
            this.elementTree?.setSearchFilter(e.target.value);
        });

        // Wire up tree filters
        document.getElementById('treeFilterClickable')?.addEventListener('change', (e) => {
            this.elementTree?.setFilterOptions({ clickableOnly: e.target.checked });
        });

        document.getElementById('treeFilterText')?.addEventListener('change', (e) => {
            this.elementTree?.setFilterOptions({ textOnly: e.target.checked });
        });

        console.log('[FlowWizard] Element tree initialized');
    }

    /**
     * Toggle element tree panel visibility
     */
    toggleTreeView(show = null) {
        const treePanel = document.getElementById('elementTreePanel');
        const layout = document.querySelector('.recording-layout');
        const toggleBtn = document.getElementById('btnToggleTree');

        if (!treePanel || !layout) return;

        // Determine new state
        this.isTreeViewOpen = show !== null ? show : !this.isTreeViewOpen;

        if (this.isTreeViewOpen) {
            treePanel.style.display = 'flex';
            layout.classList.add('split-view');
            toggleBtn?.classList.add('active');

            // Update tree with current elements
            const elements = this.recorder?.screenshotMetadata?.elements || [];
            this.elementTree?.setElements(elements);
        } else {
            treePanel.style.display = 'none';
            layout.classList.remove('split-view');
            toggleBtn?.classList.remove('active');
        }

        console.log(`[FlowWizard] Tree view ${this.isTreeViewOpen ? 'opened' : 'closed'}`);
    }

    /**
     * Handle tap action from tree
     */
    handleTreeTap(element) {
        if (!element?.bounds) return;

        const bounds = element.bounds;
        const x = bounds.x + bounds.width / 2;
        const y = bounds.y + bounds.height / 2;

        console.log(`[FlowWizard] Tree tap on element at (${x}, ${y})`);

        // Execute tap on device
        this.recorder?.executeTap(x, y);

        // Add step to flow
        this.recorder?.addStep({
            step_type: 'tap',
            x: Math.round(x),
            y: Math.round(y),
            description: `Tap "${element.text || element.class}"`
        });

        showToast('Tap recorded from tree', 'success', 1500);
        this.refreshAfterAction(500);
    }

    /**
     * Handle sensor action from tree
     */
    async handleTreeSensor(element) {
        if (!element) return;

        console.log('[FlowWizard] Tree sensor for element:', element);

        // Calculate coordinates from element bounds
        const bounds = element.bounds || {};
        const coords = {
            x: Math.round((bounds.x || 0) + (bounds.width || 0) / 2),
            y: Math.round((bounds.y || 0) + (bounds.height || 0) / 2)
        };

        // Go directly to text sensor creation (most common case from element tree)
        await this.createTextSensor(element, coords);
    }

    /**
     * Update tree with new elements
     */
    updateElementTree(elements) {
        // Element tree is always visible in right panel
        if (this.elementTree) {
            this.elementTree.setElements(elements);
        }
    }

    toggleScale() {
        this.scaleMode = this.canvasRenderer.toggleScale();

        const btn = document.getElementById('qabScale');
        if (btn) {
            btn.classList.toggle('active', this.scaleMode === '1:1');
            btn.title = this.scaleMode === 'fit' ? 'Toggle 1:1 Scale' : 'Toggle Fit to Screen';
        }

        console.log(`[FlowWizard] Scale mode: ${this.scaleMode}`);
        // In streaming mode, just apply CSS zoom - don't re-render screenshot
        if (this.captureMode === 'streaming') {
            this.canvasRenderer.applyZoom();
        } else {
            this.updateScreenshotDisplay();
        }
    }

    zoomIn() {
        const zoomLevel = this.canvasRenderer.zoomIn();
        this.updateZoomDisplay(zoomLevel);
        // In streaming mode, just apply CSS zoom - don't re-render screenshot
        if (this.captureMode === 'streaming') {
            this.canvasRenderer.applyZoom();
        } else {
            this.updateScreenshotDisplay();
        }
    }

    zoomOut() {
        const zoomLevel = this.canvasRenderer.zoomOut();
        this.updateZoomDisplay(zoomLevel);
        // In streaming mode, just apply CSS zoom - don't re-render screenshot
        if (this.captureMode === 'streaming') {
            this.canvasRenderer.applyZoom();
        } else {
            this.updateScreenshotDisplay();
        }
    }

    resetZoom() {
        const zoomLevel = this.canvasRenderer.resetZoom();
        this.updateZoomDisplay(zoomLevel);
        // In streaming mode, just apply CSS zoom - don't re-render screenshot
        if (this.captureMode === 'streaming') {
            this.canvasRenderer.applyZoom();
        } else {
            this.updateScreenshotDisplay();
        }
    }

    updateZoomDisplay(zoomLevel) {
        const display = document.getElementById('zoomLevel');
        if (display) {
            display.textContent = `${Math.round(zoomLevel * 100)}%`;
        }
    }

    /**
     * Fit to screen - reset zoom and set fit mode
     */
    fitToScreen() {
        const zoomLevel = this.canvasRenderer.fitToScreen();
        this.updateZoomDisplay(zoomLevel);
        this.scaleMode = 'fit';
        console.log('[FlowWizard] Fit to screen');
    }

    /**
     * Toggle recording pause/resume
     * When paused, gestures are executed but not recorded to the flow
     */
    toggleRecording() {
        this.recordingPaused = !this.recordingPaused;

        const btn = document.getElementById('qabRecordToggle');
        const label = btn?.querySelector('.btn-label');
        const icon = btn?.querySelector('.btn-icon');

        if (this.recordingPaused) {
            btn?.classList.remove('recording-active');
            btn?.classList.add('recording-paused');
            if (label) label.textContent = 'Paused';
            if (icon) icon.textContent = '‚è∏';
            showToast('Recording paused - actions will not be saved', 'info', 2000);
        } else {
            btn?.classList.remove('recording-paused');
            btn?.classList.add('recording-active');
            if (label) label.textContent = 'Recording';
            if (icon) icon.textContent = '‚è∫';
            showToast('Recording resumed', 'success', 2000);
        }

        console.log(`[FlowWizard] Recording ${this.recordingPaused ? 'paused' : 'resumed'}`);
    }

    // Removed applyCanvasScale() - now using direct canvas resizing instead of CSS transform

    async handleElementClick(canvasX, canvasY) {
        // Convert canvas coordinates to device coordinates (use appropriate converter)
        let deviceCoords;
        if (this.captureMode === 'streaming' && this.liveStream) {
            deviceCoords = this.liveStream.canvasToDevice(canvasX, canvasY);
        } else {
            deviceCoords = this.canvasRenderer.canvasToDevice(canvasX, canvasY);
        }

        // Find clicked element from metadata (use appropriate element source)
        const elements = this.captureMode === 'streaming'
            ? this.liveStream?.elements
            : this.recorder.screenshotMetadata?.elements;
        const clickedElement = this.interactions.findElementAtCoordinates(
            elements,
            deviceCoords.x,
            deviceCoords.y,
            {
                hideContainers: this.overlayFilters.hideContainers,
                hideEmptyElements: this.overlayFilters.hideEmptyElements
            }
        );

        // Show selection dialog
        const choice = await this.interactions.showElementSelectionDialog(clickedElement, deviceCoords);

        if (!choice) {
            return; // User cancelled
        }

        // Execute based on choice
        switch (choice.type) {
            case 'tap':
                await this.executeTap(deviceCoords.x, deviceCoords.y, clickedElement);
                // Only update screenshot in polling mode - streaming updates automatically
                if (this.captureMode !== 'streaming') {
                    this.updateScreenshotDisplay();
                }
                break;

            case 'type':
                const text = await this.interactions.promptForText();
                if (text) {
                    await this.executeTap(deviceCoords.x, deviceCoords.y, clickedElement);
                    await this.recorder.typeText(text);
                    // Only update screenshot in polling mode - streaming updates automatically
                    if (this.captureMode !== 'streaming') {
                        this.updateScreenshotDisplay();
                    }
                }
                break;

            case 'sensor_text':
                await this.createTextSensor(clickedElement, deviceCoords);
                break;

            case 'sensor_image':
                await this.createImageSensor(clickedElement, deviceCoords);
                break;

            case 'action':
                await this.createAction(clickedElement, deviceCoords);
                break;

            case 'refresh':
                await this.handleRefreshWithRetries();
                break;
        }
    }

    /**
     * Convert canvas coordinates to device coordinates (adapted from screenshot-capture.js)
     */
    canvasToDevice(canvasX, canvasY) {
        if (!this.currentImage || !this.canvas.width) {
            console.warn('[FlowWizard] No screenshot loaded');
            return { x: Math.round(canvasX), y: Math.round(canvasY) };
        }

        // Canvas is 1:1 with device (no scaling), so coordinates are direct
        return {
            x: Math.round(canvasX),
            y: Math.round(canvasY)
        };
    }

    /**
     * Execute tap on device and add to flow
     */
    async executeTap(x, y, element = null) {
        // Show tap indicator on canvas
        this.showTapIndicator(x, y);

        // Execute tap if in execute mode
        if (this.recordMode === 'execute') {
            await this.recorder.executeTap(x, y);
        }

        // Build step description
        let description = `Tap at (${x}, ${y})`;
        if (element) {
            if (element.text) {
                description = `Tap "${element.text}" at (${x}, ${y})`;
            } else if (element.content_desc) {
                description = `Tap "${element.content_desc}" at (${x}, ${y})`;
            } else if (element.resource_id) {
                const shortId = element.resource_id.split('/').pop() || element.resource_id;
                description = `Tap ${shortId} at (${x}, ${y})`;
            }
        }

        // Add tap step to flow with optional element metadata
        const step = {
            step_type: 'tap',
            x: x,
            y: y,
            description: description
        };

        // Include element metadata if available
        if (element) {
            step.element = {
                text: element.text || null,
                resource_id: element.resource_id || null,
                class: element.class || null,
                content_desc: element.content_desc || null,
                clickable: element.clickable || false,
                bounds: element.bounds || null
            };
        }

        // Add step to flow (unless recording is paused)
        if (!this.recordingPaused) {
            this.recorder.addStep(step);
        }

        // Capture new screenshot after tap
        if (this.recordMode === 'execute') {
            await this.recorder.wait(500); // Wait for UI to update
            await this.recorder.captureScreenshot();
        }

        // Refresh elements in streaming mode
        this.refreshAfterAction(500);
    }

    /**
     * Show visual tap indicator on canvas
     */
    showTapIndicator(x, y) {
        this.canvasRenderer.showTapIndicator(x, y);

        // Redraw screenshot after short delay to clear tap indicator
        // In streaming mode, the next frame will naturally clear it
        if (this.captureMode !== 'streaming') {
            setTimeout(() => {
                this.updateScreenshotDisplay();
            }, 300);
        }
    }

    findElementAtCoordinates(x, y) {
        if (!this.recorder.screenshotMetadata?.elements) {
            return null;
        }

        // Find element that contains the coordinates
        const elements = this.recorder.screenshotMetadata.elements;

        for (const el of elements) {
            const bounds = el.bounds || {};
            const elX = bounds.x || 0;
            const elY = bounds.y || 0;
            const elWidth = bounds.width || 0;
            const elHeight = bounds.height || 0;

            if (x >= elX && x <= elX + elWidth &&
                y >= elY && y <= elY + elHeight) {
                return el;
            }
        }

        return null;
    }

    async showElementSelectionDialog(element, coords) {
        return new Promise((resolve) => {
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.2s ease;
            `;

            const elementInfo = element ? `
                <div style="background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #3b82f6;">
                    <div style="font-size: 14px; color: #1e40af; font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 20px;">üéØ</span>
                        Element Selected
                    </div>
                    ${element.text ? `<div style="margin-bottom: 6px;"><strong>Text:</strong> ${element.text}</div>` : ''}
                    ${element.class ? `<div style="margin-bottom: 6px; font-size: 12px;"><strong>Class:</strong> <code style="background: rgba(255,255,255,0.6); padding: 2px 6px; border-radius: 3px;">${element.class}</code></div>` : ''}
                    ${element.resource_id ? `<div style="margin-bottom: 6px; font-size: 12px;"><strong>Resource ID:</strong> <code style="background: rgba(255,255,255,0.6); padding: 2px 6px; border-radius: 3px;">${element.resource_id.split('/').pop() || element.resource_id}</code></div>` : ''}
                    ${element.content_desc ? `<div style="margin-bottom: 6px;"><strong>Description:</strong> ${element.content_desc}</div>` : ''}
                    <div style="margin-bottom: 6px; font-size: 12px;"><strong>Position:</strong> (${coords.x}, ${coords.y})</div>
                    ${element.clickable ? `<div style="color: #22c55e; font-weight: 600; margin-top: 8px;">‚úì Clickable Element</div>` : '<div style="color: #64748b; margin-top: 8px;">‚óã Non-Clickable Element</div>'}
                    <div style="margin-top: 10px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 4px; font-size: 11px; color: #1e40af;">
                        <strong>Note:</strong> Steps will reference this element, not just coordinates
                    </div>
                </div>
            ` : `
                <div style="background: #fef3c7; padding: 12px; border-radius: 6px; margin-bottom: 20px; border: 2px solid #f59e0b;">
                    <div style="color: #92400e; font-size: 13px;">
                        <strong>‚ö†Ô∏è No element detected</strong><br>
                        <span style="font-size: 12px;">Using coordinates only: (${coords.x}, ${coords.y})</span>
                    </div>
                </div>
            `;

            overlay.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); animation: slideIn 0.3s ease;">
                    <h2 style="margin: 0 0 15px 0; color: #0f172a;">What do you want to do?</h2>

                    ${elementInfo}

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                        <button class="choice-btn" data-choice="tap" style="
                            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                            color: white;
                            border: none;
                            padding: 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 15px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">üëÜ</div>
                            Tap Element
                        </button>

                        <button class="choice-btn" data-choice="type" style="
                            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                            color: white;
                            border: none;
                            padding: 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 15px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">‚å®Ô∏è</div>
                            Type Text
                        </button>

                        <button class="choice-btn" data-choice="sensor_text" style="
                            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                            color: white;
                            border: none;
                            padding: 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 15px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">üìä</div>
                            Capture Text
                        </button>

                        <button class="choice-btn" data-choice="sensor_image" style="
                            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                            color: white;
                            border: none;
                            padding: 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 15px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">üì∏</div>
                            Capture Image
                        </button>

                        <button class="choice-btn" data-choice="refresh" style="
                            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
                            color: white;
                            border: none;
                            padding: 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 15px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(100, 116, 139, 0.3);
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">‚è±Ô∏è</div>
                            Wait for Update
                        </button>
                    </div>

                    <button id="btnCancelChoice" style="
                        width: 100%;
                        background: transparent;
                        color: #64748b;
                        border: 2px solid #e2e8f0;
                        padding: 12px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 600;
                        transition: all 0.2s ease;
                    ">
                        Cancel
                    </button>
                </div>
            `;

            document.body.appendChild(overlay);

            // Add hover effects
            const style = document.createElement('style');
            style.textContent = `
                .choice-btn:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2) !important;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes slideIn {
                    from { transform: scale(0.9); opacity: 0; }
                    to { transform: scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            // Handle button clicks
            overlay.querySelectorAll('.choice-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const choice = { type: btn.dataset.choice };
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    resolve(choice);
                });
            });

            document.getElementById('btnCancelChoice').addEventListener('click', () => {
                document.body.removeChild(overlay);
                document.head.removeChild(style);
                resolve(null);
            });

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    resolve(null);
                }
            });
        });
    }

    async promptForText() {
        return Dialogs.promptForText(this);
    }

    async createTextSensor(element, coords) {
        return Dialogs.createTextSensor(this, element, coords);
    }

    async createImageSensor(element, coords) {
        return Dialogs.createImageSensor(this, element, coords);
    }

    /**
     * Handle sensor created callback - adds capture_sensors step to flow
     * Called by SensorCreator.onSensorCreated callback
     */
    _handleSensorCreated(response, sensorData) {
        return Dialogs.handleSensorCreated(this, response, sensorData);
    }

    /**
     * Show action configuration dialog
     * Returns config object or null if cancelled
     */
    async promptForActionConfig(defaultName, stepCount) {
        return Dialogs.promptForActionConfig(this, defaultName, stepCount);
    }

    async createAction(element, coords) {
        return Dialogs.createAction(this, element, coords);
    }

    async promptForSensorName(defaultName) {
        return Dialogs.promptForSensorName(this, defaultName);
    }

    async handleRefreshWithRetries() {
        // Prompt for refresh configuration
        const config = await this.interactions.promptForRefreshConfig();
        if (!config) return;

        const { attempts, delay } = config;

        console.log(`[FlowWizard] Refreshing ${attempts} times with ${delay}ms delay`);

        // Perform multiple refreshes
        for (let i = 0; i < attempts; i++) {
            showToast(`Refresh ${i + 1}/${attempts}...`, 'info', 1000);
            await this.recorder.refresh(false); // Don't add step yet
            this.updateScreenshotDisplay();

            // Wait between attempts (except after the last one)
            if (i < attempts - 1) {
                await this.recorder.wait(delay);
            }
        }

        // Add a single wait step representing the total refresh operation (unless recording is paused)
        if (!this.recordingPaused) {
            const totalDuration = (attempts - 1) * delay + 500; // 500ms for screenshot capture
            this.recorder.addStep({
                step_type: 'wait',
                duration: totalDuration,
                refresh_attempts: attempts,
                refresh_delay: delay,
                description: `Wait for UI update (${attempts} refreshes, ${delay}ms delay)`
            });
        }

        showToast(`Completed ${attempts} refresh attempts`, 'success', 2000);
    }

    async updateScreenshotDisplay() {
        const dataUrl = this.recorder.getScreenshotDataUrl();
        const metadata = this.recorder.screenshotMetadata;

        try {
            // Render using canvas renderer module
            const { displayWidth, displayHeight, scale } = await this.canvasRenderer.render(dataUrl, metadata);

            // Store scale for coordinate mapping
            this.currentScale = scale;

            // Update element tree and count if metadata available
            if (metadata && metadata.elements && metadata.elements.length > 0) {
                this.updateElementTree(metadata.elements);
                this.updateElementCount(metadata.elements.length);
            }

            // Phase 1 Screen Awareness: Update screen info after each screenshot
            this.updateScreenInfo();

            // Hide loading overlay
            this.hideLoadingOverlay();

        } catch (error) {
            console.error('[FlowWizard] Failed to render screenshot:', error);
            this.showLoadingOverlay('Error loading screenshot');
        }
    }

    /**
     * Show loading overlay on screenshot
     */
    showLoadingOverlay(text = 'Loading...') {
        const overlay = document.getElementById('screenshotLoading');
        if (overlay) {
            const textEl = overlay.querySelector('.loading-text');
            if (textEl) textEl.textContent = text;
            overlay.classList.add('visible');
        }
    }

    /**
     * Hide loading overlay
     */
    hideLoadingOverlay() {
        const overlay = document.getElementById('screenshotLoading');
        if (overlay) {
            overlay.classList.remove('visible');
        }
    }

    /**
     * Update element count badge
     */
    updateElementCount(count) {
        const badge = document.getElementById('elementCount');
        if (badge) badge.textContent = count;
    }

    /**
     * Update flow steps count badge
     */
    updateFlowStepsUI() {
        const badge = document.getElementById('stepCount');
        const steps = this.recorder?.getSteps() || [];
        if (badge) badge.textContent = steps.length;

        // Update step manager display
        if (this.stepManager) {
            this.stepManager.render(steps);
        }
    }

    /**
     * Show preview overlay with screenshot method selection
     */
    showPreviewOverlay() {
        // Remove existing overlay if any
        this.hidePreviewOverlay();

        const overlay = document.createElement('div');
        overlay.id = 'previewOverlay';
        overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        `;

        const messageBox = document.createElement('div');
        messageBox.style.cssText = `
            background: white;
            padding: 30px 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            text-align: center;
        `;

        const title = document.createElement('h3');
        title.textContent = 'üì∏ Preview of Current Screen';
        title.style.cssText = 'margin: 0 0 15px; color: #1f2937; font-size: 20px;';

        const description = document.createElement('p');
        description.textContent = 'This is a quick preview. Choose your capture method to begin recording:';
        description.style.cssText = 'margin: 0 0 25px; color: #6b7280; font-size: 14px; line-height: 1.5;';

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 12px; justify-content: center;';

        const regularBtn = document.createElement('button');
        regularBtn.textContent = 'üìã Regular Screenshot';
        regularBtn.className = 'btn btn-primary';
        regularBtn.style.cssText = 'padding: 12px 24px; font-size: 14px;';
        regularBtn.onclick = () => this.chooseRegularScreenshot();

        const stitchBtn = document.createElement('button');
        stitchBtn.textContent = 'üß© Stitch Capture';
        stitchBtn.className = 'btn btn-secondary';
        stitchBtn.style.cssText = 'padding: 12px 24px; font-size: 14px;';
        stitchBtn.onclick = () => this.chooseStitchCapture();

        buttonContainer.appendChild(regularBtn);
        buttonContainer.appendChild(stitchBtn);

        messageBox.appendChild(title);
        messageBox.appendChild(description);
        messageBox.appendChild(buttonContainer);
        overlay.appendChild(messageBox);

        // Add to screenshot container
        const screenshotContainer = document.getElementById('screenshotContainer');
        if (screenshotContainer) {
            screenshotContainer.appendChild(overlay);
            console.log('[FlowWizard] Preview overlay shown');
        }
    }

    /**
     * Hide preview overlay
     */
    hidePreviewOverlay() {
        const overlay = document.getElementById('previewOverlay');
        if (overlay) {
            overlay.remove();
            console.log('[FlowWizard] Preview overlay hidden');
        }
    }

    /**
     * User chose regular screenshot - capture with UI elements
     */
    async chooseRegularScreenshot() {
        this.hidePreviewOverlay();

        try {
            await this.recorder.captureScreenshot();
            await this.updateScreenshotDisplay();
            showToast(`Full screenshot captured! (${this.recorder.screenshotMetadata?.elements?.length || 0} UI elements)`, 'success', 3000);
        } catch (error) {
            console.error('[FlowWizard] Regular screenshot failed:', error);
            showToast(`Screenshot failed: ${error.message}`, 'error', 3000);
        }
    }

    /**
     * User chose stitch capture - capture stitched screenshot
     */
    async chooseStitchCapture() {
        this.hidePreviewOverlay();

        try {
            await this.recorder.stitchCapture();
            await this.updateScreenshotDisplay();
        } catch (error) {
            console.error('[FlowWizard] Stitch capture failed:', error);
            // Error already handled by stitchCapture()
        }
    }

    /**
     * Collapse the element sidebar
     */
    collapseSidebar() {
        const sidebar = document.getElementById('elementSidebar');
        const expandBtn = document.getElementById('btnExpandSidebar');
        const layout = document.querySelector('.recording-layout');

        if (sidebar) {
            sidebar.classList.add('collapsed');
        }
        if (expandBtn) {
            expandBtn.style.display = 'block';
        }
        if (layout) {
            layout.classList.add('sidebar-collapsed');
        }

        console.log('[FlowWizard] Sidebar collapsed');
    }

    /**
     * Expand the element sidebar
     */
    expandSidebar() {
        const sidebar = document.getElementById('elementSidebar');
        const expandBtn = document.getElementById('btnExpandSidebar');
        const layout = document.querySelector('.recording-layout');

        if (sidebar) {
            sidebar.classList.remove('collapsed');
        }
        if (expandBtn) {
            expandBtn.style.display = 'none';
        }
        if (layout) {
            layout.classList.remove('sidebar-collapsed');
        }

        console.log('[FlowWizard] Sidebar expanded');
    }

    /**
     * Update element panel with current elements
     */
    updateElementPanel(elements) {
        const panel = document.getElementById('elementList');
        if (!panel) {
            console.warn('[FlowWizard] Element list container not found');
            return;
        }

        // Store all elements for filtering
        this.allElements = elements || [];

        // Setup search and filter event listeners (once)
        if (!this.elementFiltersInitialized) {
            this.setupElementFilters();
            this.elementFiltersInitialized = true;
        }

        // Apply filters and render
        this.renderFilteredElements();
    }

    setupElementFilters() {
        const searchInput = document.getElementById('elementSearchInput');
        const clickableFilter = document.getElementById('filterSidebarClickable');
        const textFilter = document.getElementById('filterSidebarText');

        if (searchInput) {
            searchInput.addEventListener('input', () => this.renderFilteredElements());
        }
        if (clickableFilter) {
            clickableFilter.addEventListener('change', () => this.renderFilteredElements());
        }
        if (textFilter) {
            textFilter.addEventListener('change', () => this.renderFilteredElements());
        }
    }

    renderFilteredElements() {
        const panel = document.getElementById('elementList');
        if (!panel) return;

        const searchInput = document.getElementById('elementSearchInput');
        const clickableFilter = document.getElementById('filterSidebarClickable');
        const textFilter = document.getElementById('filterSidebarText');

        const searchTerm = searchInput?.value.toLowerCase() || '';
        const showClickable = clickableFilter?.checked !== false;
        const showWithText = textFilter?.checked !== false;

        if (!this.allElements || this.allElements.length === 0) {
            panel.innerHTML = '<div class="empty-state">No elements detected in screenshot</div>';
            return;
        }

        // Apply filters (OR logic: show if matches ANY checked filter)
        let filteredElements = this.allElements.filter(el => {
            // If both filters are off, show all
            if (!showClickable && !showWithText) return true;

            // Show if matches any checked filter
            const isClickable = el.clickable;
            const hasText = el.text && el.text.trim().length > 0;

            if (showClickable && isClickable) return true;
            if (showWithText && hasText) return true;

            return false;
        });

        // Apply search
        if (searchTerm) {
            filteredElements = filteredElements.filter(el => {
                const displayText = (el.text || el.content_desc || el.resource_id || '').toLowerCase();
                return displayText.includes(searchTerm);
            });
        }

        const interactiveElements = filteredElements;

        console.log(`[FlowWizard] Rendering ${interactiveElements.length} interactive elements (${this.allElements.length} total)`);

        panel.innerHTML = interactiveElements.map((el, index) => {
            const displayText = el.text || el.content_desc || el.resource_id?.split('/').pop() || `Element ${index}`;
            const isClickable = el.clickable === true || el.clickable === 'true';
            const icon = isClickable ? 'üîò' : 'üìù';
            const typeLabel = isClickable ? 'Clickable' : 'Text';

            // Determine preview value (what would be captured as sensor)
            const previewValue = el.text || el.content_desc || el.resource_id || '';
            const hasPreview = previewValue.trim().length > 0;
            const truncatedPreview = previewValue.length > 50
                ? previewValue.substring(0, 50) + '...'
                : previewValue;

            return `
                <div class="element-item" data-element-index="${index}">
                    <div class="element-item-header">
                        <span class="element-icon">${icon}</span>
                        <div class="element-info">
                            <div class="element-text">${displayText}</div>
                            <div class="element-meta">${typeLabel} ‚Ä¢ ${el.class?.split('.').pop() || 'Unknown'}</div>
                        </div>
                    </div>
                    ${hasPreview ? `
                    <div class="element-preview" title="${previewValue}">
                        <span class="preview-label">Preview:</span>
                        <span class="preview-value">${truncatedPreview}</span>
                    </div>
                    ` : ''}
                    <div class="element-actions">
                        <button class="btn-element-action btn-tap" data-index="${index}" title="Add tap step">
                            üëÜ Tap
                        </button>
                        <button class="btn-element-action btn-type" data-index="${index}" title="Add type step">
                            ‚å®Ô∏è Type
                        </button>
                        <button class="btn-element-action btn-sensor" data-index="${index}" title="Add sensor capture">
                            üìä Sensor
                        </button>
                        <button class="btn-element-action btn-action" data-index="${index}" title="Execute saved action">
                            ‚ö° Action
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        // Bind action buttons
        panel.querySelectorAll('.btn-tap').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                this.addTapStepFromElement(interactiveElements[index]);
            });
        });

        panel.querySelectorAll('.btn-type').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                this.addTypeStepFromElement(interactiveElements[index]);
            });
        });

        panel.querySelectorAll('.btn-sensor').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                this.addSensorCaptureFromElement(interactiveElements[index], index);
            });
        });

        panel.querySelectorAll('.btn-action').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                this.addActionStepFromElement(interactiveElements[index]);
            });
        });
    }

    /**
     * Add tap step from element (via panel)
     */
    async addTapStepFromElement(element) {
        return ElementActions.addTapStepFromElement(this, element);
    }

    /**
     * Add type step from element (via panel)
     */
    async addTypeStepFromElement(element) {
        return ElementActions.addTypeStepFromElement(this, element);
    }

    /**
     * Add sensor capture from element (via panel)
     */
    async addSensorCaptureFromElement(element, elementIndex) {
        return ElementActions.addSensorCaptureFromElement(this, element, elementIndex);
    }

    /**
     * Add action from recorded steps (via panel)
     */
    async addActionStepFromElement(element) {
        return Dialogs.addActionStepFromElement(this, element);
    }

    /**
     * Show action creation dialog with choice
     */
    async promptForActionCreation(defaultName, stepCount) {
        return Dialogs.promptForActionCreation(this, defaultName, stepCount);
    }

    /**
     * Draw UI element overlays on canvas (adapted from screenshot-capture.js)
     */
    drawElementOverlays() {
        if (!this.currentImage || !this.recorder.screenshotMetadata) {
            console.warn('[FlowWizard] Cannot draw overlays: no screenshot loaded');
            return;
        }

        // Redraw the screenshot image first (to clear old overlays)
        this.ctx.drawImage(this.currentImage, 0, 0);

        const elements = this.recorder.screenshotMetadata.elements || [];

        // Count elements by type
        const clickableElements = elements.filter(e => e.clickable === true);
        const nonClickableElements = elements.filter(e => e.clickable === false || e.clickable === undefined);

        console.log(`[FlowWizard] Drawing ${elements.length} elements (${clickableElements.length} clickable, ${nonClickableElements.length} non-clickable)`);
        console.log('[FlowWizard] Overlay filters:', this.overlayFilters);

        let visibleCount = 0;
        let drawnCount = 0;
        let filteredClickable = 0;
        let filteredNonClickable = 0;
        let drawnClickable = 0;
        let drawnNonClickable = 0;

        elements.forEach(el => {
            // Only draw elements with bounds
            if (!el.bounds) {
                return;
            }

            visibleCount++;

            // Apply filters (same as screenshot-capture.js)
            if (el.clickable && !this.overlayFilters.showClickable) {
                filteredClickable++;
                return;
            }
            if (!el.clickable && !this.overlayFilters.showNonClickable) {
                filteredNonClickable++;
                return;
            }

            // Filter by size (hide small elements < 50px width or height)
            if (this.overlayFilters.hideSmall && (el.bounds.width < 50 || el.bounds.height < 50)) {
                if (el.clickable) filteredClickable++; else filteredNonClickable++;
                return;
            }

            // Filter: text elements only
            if (this.overlayFilters.textOnly && (!el.text || !el.text.trim())) {
                if (el.clickable) filteredClickable++; else filteredNonClickable++;
                return;
            }

            // Get coordinates (no scaling - 1:1)
            const x = el.bounds.x;
            const y = el.bounds.y;
            const w = el.bounds.width;
            const h = el.bounds.height;

            // Skip elements outside canvas
            if (x + w < 0 || x > this.canvas.width || y + h < 0 || y > this.canvas.height) {
                return;
            }

            // Draw bounding box
            // Green for clickable, blue for non-clickable (matching flow-wizard colors)
            this.ctx.strokeStyle = el.clickable ? '#22c55e' : '#3b82f6';
            this.ctx.fillStyle = el.clickable ? 'rgba(34, 197, 94, 0.1)' : 'rgba(59, 130, 246, 0.1)';
            this.ctx.lineWidth = 2;

            // Fill background
            this.ctx.fillRect(x, y, w, h);

            // Draw border
            this.ctx.strokeRect(x, y, w, h);
            drawnCount++;
            if (el.clickable) drawnClickable++; else drawnNonClickable++;

            // Draw text label if element has text (and labels are enabled)
            if (this.overlayFilters.showTextLabels && el.text && el.text.trim()) {
                this.drawTextLabel(el.text, x, y, w, el.clickable);
            }
        });

        console.log(`[FlowWizard] Total visible: ${visibleCount}`);
        console.log(`[FlowWizard] Filtered: ${filteredClickable + filteredNonClickable} (${filteredClickable} clickable, ${filteredNonClickable} non-clickable)`);
        console.log(`[FlowWizard] Drawn: ${drawnCount} (${drawnClickable} clickable, ${drawnNonClickable} non-clickable)`);
    }

    /**
     * Draw UI element overlays with scaling
     */
    drawElementOverlaysScaled(scale) {
        if (!this.currentImage || !this.recorder.screenshotMetadata) {
            console.warn('[FlowWizard] Cannot draw overlays: no screenshot loaded');
            return;
        }

        const elements = this.recorder.screenshotMetadata.elements || [];

        elements.forEach(el => {
            if (!el.bounds) return;

            // Apply overlay filters
            if (el.clickable && !this.overlayFilters.showClickable) return;
            if (!el.clickable && !this.overlayFilters.showNonClickable) return;
            if (this.overlayFilters.hideSmall && (el.bounds.width < 50 || el.bounds.height < 50)) return;
            if (this.overlayFilters.textOnly && (!el.text || !el.text.trim())) return;

            // Scale coordinates
            const x = Math.floor(el.bounds.x * scale);
            const y = Math.floor(el.bounds.y * scale);
            const w = Math.floor(el.bounds.width * scale);
            const h = Math.floor(el.bounds.height * scale);

            // Skip elements outside canvas
            if (x + w < 0 || x > this.canvas.width || y + h < 0 || y > this.canvas.height) return;

            // Draw bounding box
            this.ctx.strokeStyle = el.clickable ? '#22c55e' : '#3b82f6';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x, y, w, h);

            // Draw text label if element has text and showTextLabels is enabled
            if (el.text && el.text.trim() && this.overlayFilters.showTextLabels) {
                this.drawTextLabel(el.text.trim(), x, y, w, el.clickable);
            }
        });
    }

    /**
     * Draw text label for UI element on canvas (adapted from screenshot-capture.js)
     */
    drawTextLabel(text, x, y, w, isClickable) {
        const labelHeight = 20;
        const padding = 2;

        // Truncate long text
        const maxChars = Math.floor(w / 7); // Approximate chars that fit
        const displayText = text.length > maxChars
            ? text.substring(0, maxChars - 3) + '...'
            : text;

        // Draw background (matching element color)
        this.ctx.fillStyle = isClickable ? '#22c55e' : '#3b82f6';
        this.ctx.fillRect(x, y, w, labelHeight);

        // Draw text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = '12px monospace';
        this.ctx.textBaseline = 'top';
        this.ctx.fillText(displayText, x + padding, y + padding);
    }

    setupFlowStepsListener() {
        const stepsList = document.getElementById('flowStepsList');

        window.addEventListener('flowStepAdded', (e) => {
            const { step, index } = e.detail;

            const stepHtml = `
                <div class="flow-step-item" data-step-index="${index}">
                    <div class="step-number-badge">${index + 1}</div>
                    <div class="step-content">
                        <div class="step-description">${step.description}</div>
                    </div>
                    <div class="step-actions">
                        <button class="btn btn-sm" onclick="window.flowWizard.recorder.removeStep(${index})">‚úï</button>
                    </div>
                </div>
            `;

            stepsList.insertAdjacentHTML('beforeend', stepHtml);

            // Auto-switch to Flow tab when step is added
            this.switchToTab('flow');

            // Update step count badge
            this.updateFlowStepsUI();
        });

        window.addEventListener('flowStepRemoved', (e) => {
            const { index } = e.detail;
            const stepEl = stepsList.querySelector(`[data-step-index="${index}"]`);
            if (stepEl) stepEl.remove();

            // Renumber remaining steps
            stepsList.querySelectorAll('.flow-step-item').forEach((el, i) => {
                el.dataset.stepIndex = i;
                el.querySelector('.step-number-badge').textContent = i + 1;
            });

            // Update step count badge
            this.updateFlowStepsUI();
        });
    }

    // NOTE: loadStep4() moved to flow-wizard-step4.js
    // NOTE: formatStepType, generateStepDescription, renderStepDetails are in flow-step-manager.js

    removeStepAt(index) {
        if (index >= 0 && index < this.flowSteps.length) {
            const removed = this.flowSteps.splice(index, 1)[0];
            console.log(`Removed step ${index}:`, removed);
            showToast(`Step ${index + 1} removed`, 'info');
            Step4.loadStep(this); // Refresh the review display
        }
    }

    async testFlow() {
        console.log('Testing flow...');
        showToast('Running flow test...', 'info');

        const testResults = document.getElementById('testResults');
        const testResultsContent = document.getElementById('testResultsContent');

        testResults.style.display = 'block';
        testResultsContent.innerHTML = '<div class="loading">Executing flow...</div>';

        try {
            // Build flow payload
            const flowPayload = {
                flow_id: `test_${Date.now()}`,
                device_id: this.selectedDevice,
                name: 'Test Flow',
                description: 'Flow test execution',
                steps: this.flowSteps,
                update_interval_seconds: 60,
                enabled: false, // Don't enable test flows
                stop_on_error: true
            };

            console.log('Testing flow:', flowPayload);

            const response = await fetch(`${getApiBase()}/flows`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(flowPayload)
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to create test flow');
            }

            const createdFlow = await response.json();
            console.log('Test flow created:', createdFlow);

            // Execute the flow
            const executeResponse = await fetch(`${getApiBase()}/flows/${this.selectedDevice}/${createdFlow.flow_id}/execute`, {
                method: 'POST'
            });

            if (!executeResponse.ok) {
                const error = await executeResponse.json();
                throw new Error(error.detail || 'Flow execution failed');
            }

            const result = await executeResponse.json();
            console.log('Flow execution result:', result);

            // Display results
            if (result.success) {
                testResultsContent.innerHTML = `
                    <div class="test-success">
                        <h4>‚úÖ Flow Test Passed</h4>
                        <p><strong>Executed Steps:</strong> ${result.executed_steps} / ${this.flowSteps.length}</p>
                        <p><strong>Execution Time:</strong> ${result.execution_time_ms}ms</p>
                        ${Object.keys(result.captured_sensors || {}).length > 0 ? `
                            <div class="captured-sensors">
                                <strong>Captured Sensors:</strong>
                                <ul>
                                    ${Object.entries(result.captured_sensors).map(([id, value]) =>
                                        `<li>${id}: ${value}</li>`
                                    ).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
                showToast('Flow test passed!', 'success');
            } else {
                testResultsContent.innerHTML = `
                    <div class="test-failure">
                        <h4>‚ùå Flow Test Failed</h4>
                        <p><strong>Failed at Step:</strong> ${result.failed_step !== null ? result.failed_step + 1 : 'Unknown'}</p>
                        <p><strong>Error:</strong> ${result.error_message || 'Unknown error'}</p>
                        <p><strong>Executed Steps:</strong> ${result.executed_steps} / ${this.flowSteps.length}</p>
                    </div>
                `;
                showToast('Flow test failed', 'error');
            }

            // Clean up test flow
            await fetch(`${getApiBase()}/flows/${this.selectedDevice}/${createdFlow.flow_id}`, {
                method: 'DELETE'
            });

        } catch (error) {
            console.error('Flow test error:', error);
            testResultsContent.innerHTML = `
                <div class="test-error">
                    <h4>‚ö†Ô∏è Test Error</h4>
                    <p>${error.message}</p>
                </div>
            `;
            showToast(`Test error: ${error.message}`, 'error');
        }
    }

    // NOTE: loadStep5() moved to flow-wizard-step5.js

    async saveFlow() {
        console.log('Saving flow...');
        showToast('Saving flow...', 'info');

        try {
            // Get form values
            const flowName = document.getElementById('flowName')?.value.trim();
            const flowDescription = document.getElementById('flowDescription')?.value.trim();
            const intervalValue = parseInt(document.getElementById('intervalValue')?.value || '60');
            const intervalUnit = parseInt(document.getElementById('intervalUnit')?.value || '60');

            // Calculate total interval in seconds
            const updateIntervalSeconds = intervalValue * intervalUnit;

            // Generate unique flow ID
            const flowId = `flow_${this.selectedDevice.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;

            // Build flow payload
            const flowPayload = {
                flow_id: flowId,
                device_id: this.selectedDevice,
                name: flowName,
                description: flowDescription || '',
                steps: this.flowSteps,
                update_interval_seconds: updateIntervalSeconds,
                enabled: true, // Enable by default
                stop_on_error: false,
                max_flow_retries: 3,
                flow_timeout: 60
            };

            console.log('Saving flow:', flowPayload);

            // Save flow via API
            const response = await fetch(`${getApiBase()}/flows`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(flowPayload)
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to save flow');
            }

            const savedFlow = await response.json();
            console.log('Flow saved successfully:', savedFlow);

            showToast('Flow saved successfully!', 'success', 3000);

            // Show success message with option to view flows or create another
            const result = await this.showFlowSavedDialog(savedFlow);

            if (result === 'view') {
                window.location.href = 'flows.html';
            } else if (result === 'create') {
                // Reset wizard
                this.reset();
            }

        } catch (error) {
            console.error('Failed to save flow:', error);
            showToast(`Failed to save flow: ${error.message}`, 'error', 5000);
        }
    }

    async showFlowSavedDialog(flow) {
        return new Promise((resolve) => {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            overlay.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 30px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <h2 style="margin: 0 0 15px 0; color: #22c55e;">‚úÖ Flow Saved!</h2>
                    <p style="margin: 0 0 20px 0; color: #64748b;">
                        <strong>${flow.name}</strong> has been saved and enabled.
                    </p>
                    <div style="margin: 0 0 20px 0; padding: 15px; background: #f1f5f9; border-radius: 4px;">
                        <div style="margin-bottom: 8px;">
                            <strong>Device:</strong> ${flow.device_id}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Steps:</strong> ${flow.steps.length}
                        </div>
                        <div>
                            <strong>Update Interval:</strong> ${this.formatInterval(flow.update_interval_seconds)}
                        </div>
                    </div>
                    <p style="margin: 0 0 20px 0; font-size: 14px; color: #64748b;">
                        The flow will run automatically every ${this.formatInterval(flow.update_interval_seconds)}.
                    </p>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="btnCreateAnother" class="btn btn-secondary">
                            Create Another Flow
                        </button>
                        <button id="btnViewFlows" class="btn btn-primary">
                            View All Flows
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Handle button clicks
            document.getElementById('btnCreateAnother').onclick = () => {
                document.body.removeChild(overlay);
                resolve('create');
            };

            document.getElementById('btnViewFlows').onclick = () => {
                document.body.removeChild(overlay);
                resolve('view');
            };

            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    resolve('view');
                }
            };
        });
    }

    formatInterval(seconds) {
        if (seconds < 60) {
            return `${seconds} seconds`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            return `${minutes} minute${minutes > 1 ? 's' : ''}`;
        } else {
            const hours = Math.floor(seconds / 3600);
            return `${hours} hour${hours > 1 ? 's' : ''}`;
        }
    }
}

// Initialize wizard when module loads
const wizard = new FlowWizard();

// Export for debugging
window.flowWizard = wizard;

export default FlowWizard;
